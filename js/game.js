// Kyle Fiegener
// BEQUARKED

//// Direction enum
var Direction = 
{
    // None:       0,
    Left:       0,
    Right:      1,
    Up:         2,
    Down:       3
};
Direction.opposite = function(dir)
{
    switch (dir)
    {
     case Direction.Left:
        return Direction.Right;
     case Direction.Right:
        return Direction.Left;
     case Direction.Up:
        return Direction.Down;
     case Direction.Down:
        return Direction.Up;
    }
};

//// Alignment enum
var Alignment =
{
    None:        0,
    Vertical:    1, // Vertical and horizontal are combineable flags, for when a single
    Horizontal: 16  // quark is part of a vertical and horizontal match at the same time.
};

// Global game state information and methods
var Game = 
{
    // the DOM element all trigger() calls will be made on
    eventTarget: null,
    
    EventType:
    {
        GameStart:          "game:start",
        GameOver:           "game:over",
        BoardSwapSuccess:   "board:swapSuccess",
        BoardSwapFail:      "board:swapFail",
        BoardRemoveMatches: "board:removeMatches",
        BoardRemoveLine:    "board:removeLine",
        BoardNewQuarks:     "board:newQuarks",
        BoardGravity:       "board:gravity",
        BoardGravityBomb:   "board:gravityBomb",
        BoardStable:        "board:stable",
        FeedbackGravWait:   "feedback:gravityWait", // ?
        FeedbackLineWait:   "feedback:lineWait"     // ?
    },
    
    // Method that should be called before any other game logic is executed.
    // eTarget - The jQuery object to receive all events generated by the game.
    init: function($eTarget)
    {
        this.eventTarget = $eTarget;
        
        // iterate through all squares and fill them with quarks
        for (var gridKey in this.Grid.squares)
        {
            var currSquare = this.Grid.squares[gridKey];
            
            // fill in square with random quark
            currSquare.quark = Quark.getRandomQuark();
            
            // check if this random quark causes any matches
            // (only need to check up and left because we're filling in from those directions)
            while (this.Grid.numMatchesTo(currSquare, Direction.Left) >= 2 || this.Grid.numMatchesTo(currSquare, Direction.Up) >= 2)
            {   // get a new random quark
                currSquare.quark = Quark.getRandomQuark();
            }
        }
        
        this.eventTarget.trigger(Game.EventType.GameStart, [Game.Grid.squares]);
    },
    
    animating:  false, // input ignored and game logic paused while true
    turn:       1,
    
    player1Score:       0,
    player1ChainScore:  0,
    player1ChainMult:   0,
    
    // player2Score:       0,
    // player2ChainScore:  0,
    // player2ChainMult:   0,
    
    movesMade:  0,
    maxMoves:   6, // after `maxMoves` moves between both players the game is over
    
    //matchSquares: null,
    
    matchGroups: [],
    
    gravHolesAll: {},
    gravHolesDir: [{}, {}, {}, {}],
    
    gravCumulation: [0, 0, 0, 0],
    gravPriority:   [0, 1, 2, 3],
    
    gravBombs: [],
    
    spawnSquares: [],
    
    dirtySquares: [],
    
    Grid:
    {
        squares:
        {   // Cleverness or whimsy? You decide!
            0x00: new Square(0, 0,  0x00),
            0x10: new Square(1, 0,  0x10),
            0x20: new Square(2, 0,  0x20),
            0x30: new Square(3, 0,  0x30),
            0x40: new Square(4, 0,  0x40),
            0x50: new Square(5, 0,  0x50),
            0x60: new Square(6, 0,  0x60),
            0x70: new Square(7, 0,  0x70),
            
            0x01: new Square(0, 1,  0x01),
            0x11: new Square(1, 1,  0x11),
            0x21: new Square(2, 1,  0x21),
            0x31: new Square(3, 1,  0x31),
            0x41: new Square(4, 1,  0x41),
            0x51: new Square(5, 1,  0x51),
            0x61: new Square(6, 1,  0x61),
            0x71: new Square(7, 1,  0x71),
            
            0x02: new Square(0, 2,  0x02),
            0x12: new Square(1, 2,  0x12),
            0x22: new Square(2, 2,  0x22),
            0x32: new Square(3, 2,  0x32),
            0x42: new Square(4, 2,  0x42),
            0x52: new Square(5, 2,  0x52),
            0x62: new Square(6, 2,  0x62),
            0x72: new Square(7, 2,  0x72),
            
            0x03: new Square(0, 3,  0x03),
            0x13: new Square(1, 3,  0x13),
            0x23: new Square(2, 3,  0x23),
            0x33: new Square(3, 3,  0x33),
            0x43: new Square(4, 3,  0x43),
            0x53: new Square(5, 3,  0x53),
            0x63: new Square(6, 3,  0x63),
            0x73: new Square(7, 3,  0x73),
            
            0x04: new Square(0, 4,  0x04),
            0x14: new Square(1, 4,  0x14),
            0x24: new Square(2, 4,  0x24),
            0x34: new Square(3, 4,  0x34),
            0x44: new Square(4, 4,  0x44),
            0x54: new Square(5, 4,  0x54),
            0x64: new Square(6, 4,  0x64),
            0x74: new Square(7, 4,  0x74),
            
            0x05: new Square(0, 5,  0x05),
            0x15: new Square(1, 5,  0x15),
            0x25: new Square(2, 5,  0x25),
            0x35: new Square(3, 5,  0x35),
            0x45: new Square(4, 5,  0x45),
            0x55: new Square(5, 5,  0x55),
            0x65: new Square(6, 5,  0x65),
            0x75: new Square(7, 5,  0x75),
            
            0x06: new Square(0, 6,  0x06),
            0x16: new Square(1, 6,  0x16),
            0x26: new Square(2, 6,  0x26),
            0x36: new Square(3, 6,  0x36),
            0x46: new Square(4, 6,  0x46),
            0x56: new Square(5, 6,  0x56),
            0x66: new Square(6, 6,  0x66),
            0x76: new Square(7, 6,  0x76),
            
            0x07: new Square(0, 7,  0x07),
            0x17: new Square(1, 7,  0x17),
            0x27: new Square(2, 7,  0x27),
            0x37: new Square(3, 7,  0x37),
            0x47: new Square(4, 7,  0x47),
            0x57: new Square(5, 7,  0x57),
            0x67: new Square(6, 7,  0x67),
            0x77: new Square(7, 7,  0x77)
        },
        
        // Encode x and y coordinates into fancy(/whimsical) hex byte key
        makeGridKey: function(x, y)
        {
            return (x << 4) | y;
        },
        
        getSquare: function(x, y)
        {
            var key = this.makeGridKey(x, y);
            
            if (!(key in this.squares))
                return null;
            
            return this.squares[key];
        },
        
        checkAnyMatchesTo: function(currSquare)
        {
            var hMatches = 1 + this.numMatchesTo(currSquare, Direction.Left) + this.numMatchesTo(currSquare, Direction.Right);
            if (hMatches >= 3)
                return true;
           
            var vMatches = 1 + this.numMatchesTo(currSquare, Direction.Up) + this.numMatchesTo(currSquare, Direction.Down);
            if (vMatches >= 3)
                return true;
           
            return false;
        },
        
        // returns array of squares of length `number` starting from `currSquare` and going in `direction` on the grid
        getNumSquaresFrom: function(number, currSquare, direction)
        {
            if (number <= 0 || currSquare == null) // passed 0 or over the edge of the grid
                return [];  // return empty array
            
            var nextSquare = currSquare.neighborInDir(direction);
            
            var arrOfSquares;
            number--;
            
            if (number)
            {
                arrOfSquares = this.getNumSquaresFrom(number, nextSquare, direction);
            }
            else
                arrOfSquares = [];
            
            arrOfSquares.push(currSquare);
            
            return arrOfSquares;
        },
        
        numMatchesTo: function(currSquare, direction)
        {
            var nextSquare = currSquare.neighborInDir(direction);
            
            
            if (nextSquare == null || currSquare.quark != nextSquare.quark)
                return 0;
            
            return 1 + this.numMatchesTo(nextSquare, direction);
        }
    },
    
    // swapQuarks
    swapQuarks: function(squareA, squareB)
    {
        var quarkA = squareA.quark;
        var quarkB = squareB.quark;
        
        if (quarkA == quarkB) // switching identical quarks will never produce a match
        {
            Game.eventTarget.trigger(Game.EventType.BoardSwapFail, [squareA, squareB]);
            
            return;
        }
        
        // Temporarily swap quarks to check if a match is produced
        squareA.quark = quarkB;
        squareB.quark = quarkA;
        
        if (!(Game.Grid.checkAnyMatchesTo(squareA) || Game.Grid.checkAnyMatchesTo(squareB)))
        {   // Bust, switch back.
            squareA.quark = quarkA;
            squareB.quark = quarkB;
            
            Game.eventTarget.trigger(Game.EventType.BoardSwapFail, [squareA, squareB]);
            
            return;
        }
        
        var squaresAandB = [squareA, squareB];
        
        Game.eventTarget.trigger(Game.EventType.BoardSwapSuccess, squaresAandB);
        
        Game.processMovedQuarks(squaresAandB);
    },
    
    processMovedQuarks: function(movedQuarks)
    {        
        var matchSquares = Game.getMatchesForSquares(movedQuarks);
        
        if (matchSquares.length > 0)
        {
            Game.removeMatches(matchSquares);
        }
        else // no matches found, board is stable, score chain is finished and can be added 
        {
            Game.movesMade++;
            
            //var eventData = [Game.turn];
            Game.player1Score += Game.player1ChainScore * Game.player1ChainMult;
            Game.player1ChainScore = 0;
            Game.player1ChainMult = 0;
            
            // eventData.push(Game.turn);
            // eventData.push(Game.player1Score);
            
            var eventData = [Game.player1Score];
            
          /*switch (Game.turn)
            {
                case 1:
                    //Game.turn = 2;
                    Game.player1Score += Game.player1ChainScore * Game.player1ChainMult;
                    Game.player1ChainScore = 0;
                    Game.player1ChainMult = 0;
                    
                    eventData.push(Game.turn);
                    eventData.push(Game.player1Score);
                    break;
                case 2:
                    //Game.turn = 1;
                    Game.player2Score += Game.player2ChainScore * Game.player2ChainMult;
                    Game.player2ChainScore = 0;
                    Game.player2ChainMult = 0;
                    
                    eventData.push(Game.turn);
                    eventData.push(Game.player2Score);
                    break;
            }*/
            
            if (Game.animating)
            {   // wait until finished
                var timer = window.setInterval(function()
                {
                    if (!Game.animating)
                    {
                        window.clearInterval(timer);
                        
                        Game.eventTarget.trigger(Game.EventType.BoardStable, eventData);
                        if (Game.movesMade >= Game.maxMoves)
                        {
                            Game.Over();
                        }
                    }
                }, 10);
            }
            else
            {
                Game.eventTarget.trigger(Game.EventType.BoardStable, eventData);
                if (Game.movesMade >= Game.maxMoves)
                {
                    Game.Over();
                }
            }
        }
    },
    
    // getMatchesForSquares
    getMatchesForSquares: function(squaresToMatch)
    {
        var matchSquares = [];
        
        squaresToMatch.forEach(function(currSquare)
        {
            currSquare.matchAlignment = Alignment.None; // reset matchAlignment
            
            var matches = false;
            
            var numMatchesToLeft = Game.Grid.numMatchesTo(currSquare, Direction.Left);
            var numMatchesToRight = Game.Grid.numMatchesTo(currSquare, Direction.Right);
            
            var numMatchesAbove = Game.Grid.numMatchesTo(currSquare, Direction.Up);
            var numMatchesBelow = Game.Grid.numMatchesTo(currSquare, Direction.Down);
            
            [Alignment.Horizontal, Alignment.Vertical].forEach(function(lineAlignment)
            {
                if ((lineAlignment === Alignment.Horizontal && 1 + numMatchesToLeft + numMatchesToRight >= 3) ||
                    (lineAlignment === Alignment.Vertical   && 1 + numMatchesAbove + numMatchesBelow >= 3))
                {
                    matches = true;
                    
                    var lineMatch = [currSquare]; // start with current square
                    
                    if (lineAlignment == Alignment.Horizontal)
                    {    
                        lineMatch = lineMatch.concat(Game.Grid.getNumSquaresFrom(numMatchesToLeft, currSquare.squareLeft, Direction.Left));
                        lineMatch = lineMatch.concat(Game.Grid.getNumSquaresFrom(numMatchesToRight, currSquare.squareRight, Direction.Right));
                    }
                    else // Alignment.Vertical
                    {
                        lineMatch = lineMatch.concat(Game.Grid.getNumSquaresFrom(numMatchesAbove, currSquare.squareAbove, Direction.Up));
                        lineMatch = lineMatch.concat(Game.Grid.getNumSquaresFrom(numMatchesBelow, currSquare.squareBelow, Direction.Down));
                    }
                    
                    var matchGravDir = currSquare.quark.gravDir;
                    var matchGravStrength = 0;
                    
                    // gravity direction parallel to match alignment
                    if ((lineAlignment === Alignment.Horizontal && (matchGravDir == Direction.Right || matchGravDir == Direction.Left)) ||
                        (lineAlignment === Alignment.Vertical   && (matchGravDir == Direction.Up || matchGravDir == Direction.Down)))
                    {
                        matchGravStrength = lineMatch.length;
                    }
                    else // gravity direction perpendicular to match alignment
                    {
                        matchGravStrength = 1;
                    }
                    
                    // Probably won't use this...
                    // Game.gravCumulation[matchGravDir] += matchGravStrength; // increase priority for this grav direction
                    
                    // Create MatchGroup object that will be used later for gravity resolution
                    var matchGroup = new Game.MatchGroup();
                    var matchGroupIndex = -1;
                    
                    // store this match alignment in the square
                    lineMatch.forEach(function(lineSquare)
                    {
                        lineSquare.matchAlignment |= lineAlignment;
                        
                        // set a dirty flag on the square
                        if (!lineSquare.dirty)
                        {
                            lineSquare.dirty = true;
                            Game.dirtySquares.push(lineSquare);
                        }
                        
                        lineSquare.gravDir = matchGravDir;
                        // if square already has a gravStrength, only change if new one is larger
                        lineSquare.gravStrength = Math.max(lineSquare.gravStrength, matchGravStrength);
                        
                        // store this square in the MatchGroup
                        matchGroup.squares[lineSquare.gridKey] = lineSquare;
                                                
                        if (lineSquare.matchGroupIndex != -1) // if this square is already in a match group
                        {
                            if (matchGroupIndex != -1) // This shouldn't be possible.
                                console.log("DOUBLE ASSIGNING MATCH GROUP WHAAAT?");
                            
                            // store index of existing MatchGroup to merge with later
                            matchGroupIndex = lineSquare.matchGroupIndex;
                        }
                    });
                    //lineMatch.sort(Square.compareFunction);
                    
                    // either add matchGroup to Game.matchGroups, or merge with an existing group in Game.matchGroups
                    if (matchGroupIndex == -1) // if matchGroupIndex wasn't assigned in the forEach above, then matchGroup is new
                    {
                        matchGroup.assignIndexToSquares(Game.matchGroups.length);
                        Game.matchGroups.push(matchGroup);
                    }
                    else // merge with existing MatchGroup
                    {
                        matchGroup.assignIndexToSquares(matchGroupIndex);
                        // merge objects (using jQuery)
                        $.extend(Game.matchGroups[matchGroupIndex], matchGroup);
                    }
                    
                    // rowMatches.push(lineMatch);
                    matchSquares = matchSquares.concat(lineMatch);
                }
            });
            
            if (!matches && currSquare.dirty)
            {
                currSquare.dirty = false;
                Game.dirtySquares.remove(currSquare);
            }
        });
        
        // var matchData = {};
        
        // hMatchSquares.forEach(function(currSquare)
        // {
        //     matchData[currSquare.gridKey] = new Game.MatchDatum(currSquare, Alignment.Horizontal);
        // });
        
        // vMatchSquares.forEach(function(currSquare)
        // {
        //     if (currSquare.gridKey in matchData)
        //     {
        //         matchData[currSquare.gridKey].orientation = Alignment.Horizontal | Alignment.Vertical;
        //     }
        //     else
        //     {
        //         matchData[currSquare.gridKey] = new Game.MatchDatum(currSquare, Alignment.Vertical);
        //     }
        // });
        
        //return matchData;
        //return hMatchSquares.concat(vMatchSquares);
        return matchSquares;
    },
    
    //removeMatches: function(matchData)
    removeMatches: function(matchSquares)
    {        
        // var matchPoints = Object.keys(matchData).length * 100;
        var matchPoints = matchSquares.length * 100;
        
        // set square quarks to null
        matchSquares.forEach(function(currSquare)
        {
            currSquare.quark = null;
            
            if (currSquare.state == Square.State.Quark) // state hasn't been updated yet
            {
                // get adjacent square in direction opposite to gravDir
                var oppSquare = currSquare.neighborInDir(Direction.opposite(currSquare.gravDir));
                if (oppSquare != null && oppSquare.gravDir == Direction.opposite(currSquare.gravDir))
                {
                    //Game.gravBombs[currSquare.gridKey] = currSquare;
                    //Game.gravBombs[oppSquare.gridKey] = oppSquare;
                    Game.gravBombs.push([currSquare, oppSquare]);
                    
                    currSquare.state = Square.State.GravityBomb;
                    oppSquare.state = Square.State.GravityBomb;
                    
                    // remove grav bombs from match groups
                    if (currSquare.matchGroupIndex != -1)
                    {
                        delete Game.matchGroups[currSquare.matchGroupIndex].squares[currSquare.gridKey];
                        currSquare.matchGroupIndex = -1;
                    }
                    if (oppSquare.matchGroupIndex != -1)
                    {
                        delete Game.matchGroups[oppSquare.matchGroupIndex].squares[oppSquare.gridKey];
                        oppSquare.matchGroupIndex = -1;
                    }
                }
                else
                {
                    Game.gravHolesAll[currSquare.gridKey] = currSquare;
                    Game.gravHolesDir[currSquare.gravDir][currSquare.gridKey] = currSquare;
                    
                    currSquare.state = Square.State.Gravity;
                }
            }
        });
        
        // var eventData = [matchData];
        var eventData = [matchSquares];
        
        eventData.push(Game.gravBombs);
        
        Game.player1ChainScore += matchPoints;
        Game.player1ChainMult += 1;
        eventData.push(Game.player1ChainScore);
        eventData.push(Game.player1ChainMult);
        
        // switch (Game.turn)
        // {
        //     case 1:
        //         Game.player1ChainScore += matchPoints;
        //         Game.player1ChainMult += 1;
        //         eventData.push(Game.player1ChainScore);
        //         eventData.push(Game.player1ChainMult);
        //         break;
        //     case 2:
        //         Game.player2ChainScore += matchPoints;
        //         Game.player2ChainMult += 1;
        //         eventData.push(Game.player2ChainScore);
        //         eventData.push(Game.player2ChainMult);
        //         break;
        // }
        
        if (Game.animating)
        {   // wait until finished
            var timer = window.setInterval(function()
            {
                if (!Game.animating)
                {
                    window.clearInterval(timer);
                    
                    Game.eventTarget.trigger(Game.EventType.BoardRemoveMatches, eventData);
                    // Game.spawnNewQuarks(matchData);
                    // Game.spawnNewQuarks(matchSquares);
                    Game.processGravity();
                }
            }, 10);
        }
        else
        {
            Game.eventTarget.trigger(Game.EventType.BoardRemoveMatches, eventData);
            // Game.spawnNewQuarks(matchData);
            // Game.spawnNewQuarks(matchSquares);
            Game.processGravity();
        }
    },
    
    processGravity: function()
    {
        //if (Object.keys(Game.gravHolesAll).length == 0 && Object.keys(Game.gravBombs).length == 0)
        if (Game.matchGroups.length == 0 && Game.gravBombs.length == 0)
        {
            Game.spawnNewQuarks(Game.spawnSquares);
        }
        else
        {
            // TODO: Actual gravity logic
            Game.gravBombs.forEach(function(gravBomb)
            {
                
            });
            
            //// TEMPORARY
            // for now new quarks will just appear where the old ones were
            Game.spawnSquares = Game.dirtySquares.slice(); // shallow copy
            //Game.spawnSquares = Game.dirtySquares.singleDepthCopy();
            //Game.gravHolesAll = {};
            //Game.gravHolesDir = [{}, {}, {}, {}];
            Game.gravBombs = [];
            Game.matchGroups = [];
            
            Game.processGravity();
        }
    },
    
    // spawnNewQuarks: function(matchData)
    spawnNewQuarks: function(fillSquares)
    {
        fillSquares.forEach(function(currSquare)
        {
            currSquare.spawnQuark();
            //currSquare.quark = Quark.getRandomQuark();
            //currSquare.state = Square.State.Quark;
        });
        
        if (Game.animating)
        {   // wait until finished
            var timer = window.setInterval(function()
            {
                if (!Game.animating)
                {
                    window.clearInterval(timer);
                    
                    Game.eventTarget.trigger(Game.EventType.BoardNewQuarks, [fillSquares]);
                    Game.processMovedQuarks(fillSquares);
                }
            }, 10);
        }
        else
        {
            Game.eventTarget.trigger(Game.EventType.BoardNewQuarks, [fillSquares]);
            Game.processMovedQuarks(fillSquares);
        }
    },
    
    // end game
    Over: function()
    {
        // if (Game.player1Score == Game.player2Score)
        // {
        //     Game.eventTarget.trigger(Game.EventType.GameOver, [0]);
        // }
        // else if (Game.player1Score > Game.player2Score)
        // {
        //     Game.eventTarget.trigger(Game.EventType.GameOver, [1]);
        // }
        // else
        // {
        //     Game.eventTarget.trigger(Game.EventType.GameOver, [2]);
        // }
        
        Game.eventTarget.trigger(Game.EventType.GameOver, [1]);
    },
    
    // EffectDatum object constructor
    EffectDatum: function(startSquare, alignment, length)
    {
        this.startSquare = startSquare;
        this.alignment = alignment;
        this.length = length;
    }
};
Game.MatchGroup = function()
{
    //this.totalGravStrength = 0;
    this.squares = {};
};
Object.defineProperty(Game.MatchGroup.prototype, 'assignIndexToSquares',
{
    value: function(index)
    {
        for (var gridKey in this.squares)
        {
            //if (gridKey == "totalGravStrength") // do not want
            //    continue;
            
            this[gridKey].matchGroupIndex = index;
        }
    },
    enumerable: false
});
Object.defineProperty(Game.MatchGroup.prototype, 'totalGravStrength',
{
    get: function()
    {
        var total = 0;
        
        for (var gridKey in this.squares)
        {
            //if (gridKey == "totalGravStrength")
            //    continue;
            
            total += this[gridKey].gravStrength;
        }
        
        return total;
    },
    enumerable: false
});

//// Square object constructor
function Square(x, y, gridKey)
{
    Object.defineProperty(this, 'x', { value: x, enumerable: true });
    Object.defineProperty(this, 'y', { value: y, enumerable: true });
    Object.defineProperty(this, 'gridKey', { value: gridKey, enumerable: true });
    
    this.quark = null;
    
    this.gravDir = null;
    this.gravStrength = 0;
    // this.gravUp    = 0;
    // this.gravDown  = 0;
    // this.gravLeft  = 0;
    // this.gravRight = 0;
    this.matchAlignment = Alignment.None;
    this.matchGroupIndex = -1;
    this.state = 0; // Square.State.Spawn
    
    // dirty – A "dirty" flag indicating that this square's quark has changed but has not yet been checked for matches
    this.dirty = false;
}
// enum definition
Square.State =
{
    Spawn: 0,
    Quark: 1,
    Match: 2,
    Gravity: 3,
    GravityBomb: 4
};
//// add some 'get adjacent square' properties to Square objects
Object.defineProperty(Square.prototype, 'squareAbove',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x, this.y-1); // evaluates to null when looking beyond edge of Grid
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareBelow',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x, this.y+1); // evaluates to null when looking beyond edge of Grid
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareLeft',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x-1, this.y); // evaluates to null when looking beyond edge of Grid
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareRight',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x+1, this.y); // evaluates to null when looking beyond edge of Grid
    },
    enumerable: true
});
Square.prototype.neighborInDir = function(direction)
{
    switch (direction)
    {
     case Direction.Up:
        return this.squareAbove;
        break;
     case Direction.Down:
        return this.squareBelow;
        break;
     case Direction.Left:
        return this.squareLeft;
        break;
     case Direction.Right:
        return this.squareRight;
        break;
    }
};
Square.prototype.spawnQuark = function()
{
    this.quark = Quark.getRandomQuark();
    this.state = Square.State.Quark;
    
    this.gravDir = null;
    this.gravStrength = 0;
    this.matchAlignment = Alignment.None;
    this.matchGroupIndex = -1;
};
// Returns true if this square and otherSquare have the same non-negative matchGroupIndex
Square.prototype.inSameGroupAs = function(otherSquare)
{
    return (this.matchGroupIndex != -1 && this.matchGroupIndex == otherSquare.matchGroupIndex);
};
// Checks all squares from this square to grid edge for following conditions:
// (this.gravDir == gravDir || this.gravDir == null)
// Returns true if all squares pass.
Square.prototype.checkGravityInDir = function(direction, gravDir)
{
    if (this.gravDir != null && this.gravDir != gravDir)
        return false;
    
    var nextSquare = this.neighborInDir(direction);
    return (!nextSquare || nextSquare.checkGravityInDir(direction, gravDir, gravStrength));
};
// Set gravStrength and gravDir on all squares from this square to grid edge
Square.prototype.setGravityInDir = function(direction, gravDir, gravStrength)
{
    this.gravDir = gravDir;
    this.gravStrength += gravStrength;
    
    var nextSquare = this.neighborInDir(direction);
    if (nextSquare)
    {
        nextSquare.setGravityInDir(direction, gravDir, gravStrength);
    }
};
// Comparison function for sorting arrays of squares.
Square.compareFunction = function(squareA, squareB)
{
    return squareA.gridKey - squareB.gridKey;
};

//// Quark types
var Quark =
{
    RedLeft:
    {
        gravDir: Direction.Left,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-left'
    },
    BlueLeft:
    {
        gravDir: Direction.Left,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-left'
    },
    RedUp:
    {
        gravDir: Direction.Up,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-up'
    },
    BlueUp:
    {
        gravDir: Direction.Up,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-up'
    },
    RedRight:
    {
        gravDir: Direction.Right,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-right'
    },
    BlueRight:
    {
        gravDir: Direction.Right,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-right'
    },
    RedDown:
    {
        gravDir: Direction.Down,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-down'
    },
    BlueDown:
    {
        gravDir: Direction.Down,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-down'
    },
    
    NumQuarkTypes: 8,
    
    getRandomQuark: function()
    {
        var quarkTypes = Object.keys(this);
        
        var randomIndex = Math.floor(Math.random() * this.NumQuarkTypes);
        return Quark[quarkTypes[randomIndex]];
    }
};


//// command-line only stuff for testing purposes
//if (typeof process != 'undefined')
//{    
//    console.log(Game.Grid.getSquare(5,3).neighborInDir(Direction.Up));
//}
