// Kyle Fiegener
// BEQUARKED

//// Direction enum
const Direction = 
{
    //none:       0,
    left:       1,
    right:      2,
    up:         3,
    down:       4,
    vertical:   16, // Vertical and horizontal are combineable flags, for when a single
    horizontal: 32  // quark is part of a vertical and horizontal match at the same time.
};

//// Quark types
const Quark =
{
    RedLeft:
    {
        gravDir: Direction.left,
        // CSS classes to properly represent this quark in the DOM
        cssClasses: 'ring-red arrow-left'
        //classRing:  "ring-red",
        //classArrow: "arrow-left"
    },
    BlueLeft:
    {
        gravDir: Direction.left,
        // CSS classes to properly represent this quark in the DOM
        cssClasses: 'ring-blue arrow-left'
    },
    RedUp:
    {
        gravDir: Direction.up,
        // CSS classes to properly represent this quark in the DOM
        cssClasses: 'ring-red arrow-up'
    },
    BlueUp:
    {
        gravDir: Direction.up,
        // CSS classes to properly represent this quark in the DOM
        cssClasses: 'ring-blue arrow-up'
    },
    RedRight:
    {
        gravDir: Direction.right,
        // CSS classes to properly represent this quark in the DOM
        cssClasses: 'ring-red arrow-right'
    },
    BlueRight:
    {
        gravDir: Direction.right,
        // CSS classes to properly represent this quark in the DOM
        cssClasses: 'ring-blue arrow-right'
    },
    RedDown:
    {
        gravDir: Direction.down,
        // CSS classes to properly represent this quark in the DOM
        cssClasses: 'ring-red arrow-down'
    },
    BlueDown:
    {
        gravDir: Direction.down,
        // CSS classes to properly represent this quark in the DOM
        cssClasses: 'ring-blue arrow-down'
    },
    
    numQuarkTypes: 8,
    
    getRandomQuark: function()
    {
        var quarks = Object.keys(this);
        
        var randomIndex = Math.round(Math.random() * this.numQuarkTypes);
        return quarks[randomIndex];
    }
};

// Global game state information
var Game = 
{
    // the DOM element all dispatchEvent() calls will be made on
    eventTarget: null,
    
    // Method that should be called before any other game logic is executed.
    // Parameters:
    // eTarget - The DOM element to receive all events generated by the game.
    init: function(eTarget)
    {
        this.eventTarget = eTarget;
        
        // iterate through all squares and fill them with quarks
        for (var gridKey in this.Grid.squares)
        {
            var currSquare = this.Grid.squares[gridKey];
            
            // fill in square with random quark
            currSquare.quark = Quark.getRandomQuark();
            
            // check if this random quark causes any matches
            // only need to check up and left because we're filling in from those directions
            while (findMatchesTo(currSquare, Direction.left) >= 2 || findMatchesTo(currSquare, Direction.up) >= 2)
            {   // get a new random quark
                currSquare.quark = Quark.getRandomQuark();
            }
            
            
        }
    },
    
    animating:  false, // input ignored and game logic paused while true
    turn:       1,
    
    player1Score:       0,
    player1ChainScore:  0,
    player1ChainMult:   0,
    
    player2Score:       0,
    player2ChainScore:  0,
    player2ChainMult:   0,
    
    movesMade:  0,
    maxMoves:   20, // after `maxMoves` moves between both players the game is over
    
    Grid:
    {
        squares:
        {   // Cleverness or whimsy? You decide!
            0x00: new Square(0, 0),
            0x10: new Square(1, 0),
            0x20: new Square(2, 0),
            0x30: new Square(3, 0),
            0x40: new Square(4, 0),
            0x50: new Square(5, 0),
            0x60: new Square(6, 0),
            0x70: new Square(7, 0),
            
            0x01: new Square(0, 1),
            0x11: new Square(1, 1),
            0x21: new Square(2, 1),
            0x31: new Square(3, 1),
            0x41: new Square(4, 1),
            0x51: new Square(5, 1),
            0x61: new Square(6, 1),
            0x71: new Square(7, 1),
            
            0x02: new Square(0, 2),
            0x12: new Square(1, 2),
            0x22: new Square(2, 2),
            0x32: new Square(3, 2),
            0x42: new Square(4, 2),
            0x52: new Square(5, 2),
            0x62: new Square(6, 2),
            0x72: new Square(7, 2),
            
            0x03: new Square(0, 3),
            0x13: new Square(1, 3),
            0x23: new Square(2, 3),
            0x33: new Square(3, 3),
            0x43: new Square(4, 3),
            0x53: new Square(5, 3),
            0x63: new Square(6, 3),
            0x73: new Square(7, 3),
            
            0x04: new Square(0, 4),
            0x14: new Square(1, 4),
            0x24: new Square(2, 4),
            0x34: new Square(3, 4),
            0x44: new Square(4, 4),
            0x54: new Square(5, 4),
            0x64: new Square(6, 4),
            0x74: new Square(7, 4),
            
            0x05: new Square(0, 5),
            0x15: new Square(1, 5),
            0x25: new Square(2, 5),
            0x35: new Square(3, 5),
            0x45: new Square(4, 5),
            0x55: new Square(5, 5),
            0x65: new Square(6, 5),
            0x75: new Square(7, 5),
            
            0x06: new Square(0, 6),
            0x16: new Square(1, 6),
            0x26: new Square(2, 6),
            0x36: new Square(3, 6),
            0x46: new Square(4, 6),
            0x56: new Square(5, 6),
            0x66: new Square(6, 6),
            0x76: new Square(7, 6),
            
            0x07: new Square(0, 7),
            0x17: new Square(1, 7),
            0x27: new Square(2, 7),
            0x37: new Square(3, 7),
            0x47: new Square(4, 7),
            0x57: new Square(5, 7),
            0x67: new Square(6, 7),
            0x77: new Square(7, 7)
        },
        
        // Encode x and y coordinates into fancy(/whimsical) hex byte key
        makeGridKey: function(x, y)
        {
            return (x << 4) | y;
        },
        
        getSquare: function(x, y)
        {
            var key = this.makeGridKey(x, y);
            
            if (!(key in this.squares))
                return null;
            
            return this.squares[key];
        },
        
        findMatchesTo: function(currSquare, direction)
        {
            var nextSquare;
            switch (direction)
            {
                case Direction.up:
                    nextSquare = currSquare.squareAbove;
                    break;
                case Direction.down:
                    nextSquare = currSquare.squareBelow;
                    break;
                case Direction.left:
                    nextSquare = currSquare.squareLeft;
                    break;
                case Direction.right:
                    nextSquare = currSquare.squareRight;
                    break;
            }
            
            if (nextSquare == null || currSquare.quark != nextSquare.quark)
                return 0;
            
            return 1 + this.findMatchesTo(nextSquare, direction);
        }
    }
}

//// Square object constructor
function Square(x, y)
{
    Object.defineProperty(this, 'x', { value: x, enumerable: true });
    Object.defineProperty(this, 'y', { value: y, enumerable: true });
    
    Object.defineProperty(this, 'quark', { value: null, writable: true, enumerable: true });
    
    Object.defineProperty(this, 'gravDir', { value: null, writable: true, enumerable: true });
    Object.defineProperty(this, 'gravStrength', { value: null, writable: true, enumerable: true });
};
//// add some 'get adjacent square' properties to Square objects
// evaluates to null when looking beyond edge of Grid
Object.defineProperty(Square.prototype, 'squareAbove',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x, this.y-1);
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareBelow',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x, this.y+1);
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareLeft',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x-1, this.y);
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareRight',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x+1, this.y);
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'gridKey',
{
    get: function()
    {
        return Game.Grid.makeGridKey(this.x, this.y);
    },
    enumerable: true
});

/*
        var detailObj =
        {
            matchData:  {}  // List of match information for each Square in a match,
                            // keyed by coordinates stored as a hex byte (0x53 = (5, 3)).
                            // Not that this needs to be remembered, as the whole list will be
                            // iterated through and the Square object knows its own coordinates.
            //
            //  Datum in `matchData` will be objects with the following keys:
            //  square:  The Square object that is involved in a match.
            //  orientation:  The orientation of the match this square is involved in.
            //      Possible values are Direction.vertical, Direction.horizontal, and
            //      Direction.vertical|Direction.horizontal (for quarks in more than one match)
            //
            // etc?
        };
*/

//// Returns a custom event using whatever means possible
function makeCustomEvent(eventName, detailObj)
{
    var evt;
    
    // check if CustomEvent constructor will work
    if (typeof CustomEvent === 'function')
    {
        evt = new CustomEvent(eventName, { detail: detailObj });
    }
    else // have to use the old deprecated way of making a CustomEvent
    {
        evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(eventName, false, false, detailObj);
    }
    
    return evt;
}


//// command-line only stuff for testing purposes
if (typeof process != 'undefined')
{    
    console.log(Quark.getRandomQuark());
    console.log(Quark.getRandomQuark());
    console.log(Quark.getRandomQuark());
    console.log(Quark.getRandomQuark());
    console.log(Quark.getRandomQuark());
    console.log(Quark.getRandomQuark());
    console.log(Quark.getRandomQuark());
    console.log(Quark.getRandomQuark());
    console.log(Quark.getRandomQuark());
    
    var s1 = new Square(0,0);
    var s2 = new Square(0,1);
    s1.quark = Quark.RedRight;
    s2.quark = Quark.RedRight;
    
    console.log(s1.quark, '==', s2.quark, s1.quark == s2.quark);
    console.log(s1.quark, '===', s2.quark, s1.quark === s2.quark);
}
