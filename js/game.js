// Kyle Fiegener
// BEQUARKED

//// Direction enum
const Direction = 
{
    none:       0,
    left:       1,
    right:      2,
    up:         3,
    down:       4,
    vertical:   16, // Vertical and horizontal are combineable flags, for when a single
    horizontal: 32  // quark is part of a vertical and horizontal match at the same time.
};

// Global game state information and methods
var Game = 
{
    // the DOM element all trigger() calls will be made on
    eventTarget: null,
    
    // Method that should be called before any other game logic is executed.
    // eTarget - The jQuery object to receive all events generated by the game.
    init: function($eTarget)
    {
        this.eventTarget = $eTarget;
        
        // iterate through all squares and fill them with quarks
        for (var gridKey in this.Grid.squares)
        {
            var currSquare = this.Grid.squares[gridKey];
            
            // fill in square with random quark
            currSquare.quark = Quark.getRandomQuark();
            
            // check if this random quark causes any matches
            // (only need to check up and left because we're filling in from those directions)
            while (this.Grid.findMatchesTo(currSquare, Direction.left) >= 2 || this.Grid.findMatchesTo(currSquare, Direction.up) >= 2)
            {   // get a new random quark
                currSquare.quark = Quark.getRandomQuark();
            }
        }
        
        this.eventTarget.trigger('board:start', [Game.Grid.squares]);
    },
    
    animating:  false, // input ignored and game logic paused while true
    turn:       1,
    
    player1Score:       0,
    player1ChainScore:  0,
    player1ChainMult:   0,
    
    player2Score:       0,
    player2ChainScore:  0,
    player2ChainMult:   0,
    
    movesMade:  0,
    maxMoves:   6, // after `maxMoves` moves between both players the game is over
    
    Grid:
    {
        squares:
        {   // Cleverness or whimsy? You decide!
            0x00: new Square(0, 0),
            0x10: new Square(1, 0),
            0x20: new Square(2, 0),
            0x30: new Square(3, 0),
            0x40: new Square(4, 0),
            0x50: new Square(5, 0),
            0x60: new Square(6, 0),
            0x70: new Square(7, 0),
            
            0x01: new Square(0, 1),
            0x11: new Square(1, 1),
            0x21: new Square(2, 1),
            0x31: new Square(3, 1),
            0x41: new Square(4, 1),
            0x51: new Square(5, 1),
            0x61: new Square(6, 1),
            0x71: new Square(7, 1),
            
            0x02: new Square(0, 2),
            0x12: new Square(1, 2),
            0x22: new Square(2, 2),
            0x32: new Square(3, 2),
            0x42: new Square(4, 2),
            0x52: new Square(5, 2),
            0x62: new Square(6, 2),
            0x72: new Square(7, 2),
            
            0x03: new Square(0, 3),
            0x13: new Square(1, 3),
            0x23: new Square(2, 3),
            0x33: new Square(3, 3),
            0x43: new Square(4, 3),
            0x53: new Square(5, 3),
            0x63: new Square(6, 3),
            0x73: new Square(7, 3),
            
            0x04: new Square(0, 4),
            0x14: new Square(1, 4),
            0x24: new Square(2, 4),
            0x34: new Square(3, 4),
            0x44: new Square(4, 4),
            0x54: new Square(5, 4),
            0x64: new Square(6, 4),
            0x74: new Square(7, 4),
            
            0x05: new Square(0, 5),
            0x15: new Square(1, 5),
            0x25: new Square(2, 5),
            0x35: new Square(3, 5),
            0x45: new Square(4, 5),
            0x55: new Square(5, 5),
            0x65: new Square(6, 5),
            0x75: new Square(7, 5),
            
            0x06: new Square(0, 6),
            0x16: new Square(1, 6),
            0x26: new Square(2, 6),
            0x36: new Square(3, 6),
            0x46: new Square(4, 6),
            0x56: new Square(5, 6),
            0x66: new Square(6, 6),
            0x76: new Square(7, 6),
            
            0x07: new Square(0, 7),
            0x17: new Square(1, 7),
            0x27: new Square(2, 7),
            0x37: new Square(3, 7),
            0x47: new Square(4, 7),
            0x57: new Square(5, 7),
            0x67: new Square(6, 7),
            0x77: new Square(7, 7)
        },
        
        // Encode x and y coordinates into fancy(/whimsical) hex byte key
        makeGridKey: function(x, y)
        {
            return (x << 4) | y;
        },
        
        getSquare: function(x, y)
        {
            var key = this.makeGridKey(x, y);
            
            if (!(key in this.squares))
                return null;
            
            return this.squares[key];
        },
        
        swapQuarks: function(squareA, squareB)
        {
            var quarkA = squareA.quark;
            var quarkB = squareB.quark;
            
            if (quarkA == quarkB) // switching identical quarks will never produce a match
            {
                Game.eventTarget.trigger('swap:fail', [squareA, squareB]);
                
                return;
            }
            
            // Temporarily swap quarks to check if a match is produced
            squareA.quark = quarkB;
            squareB.quark = quarkA;
            
            if (!(this.checkAnyMatchesTo(squareA) || this.checkAnyMatchesTo(squareB)))
            {   // Bust, switch back.
                squareA.quark = quarkA;
                squareB.quark = quarkB;
                
                Game.eventTarget.trigger('swap:fail', [squareA, squareB]);
                
                return;
            }
            
            var squaresAandB = [squareA, squareB];
            
            Game.eventTarget.trigger('swap:success', squaresAandB);
            
            this.removeMatches(this.getMatchDataForSquares(squaresAandB));
        },
        
        removeMatches: function(matchData)
        {
            // sneak out the extra data I might need some day
            var rowMatches = matchData.rowMatches;
            delete matchData.rowMatches;
            var colMatches = matchData.colMatches;
            delete matchData.colMatches;
            
            var matchPoints = Object.keys(matchData).length * 100;
            
            var eventData = [matchData];
            switch (Game.turn)
            {
                case 1:
                    Game.player1ChainScore += matchPoints;
                    Game.player1ChainMult += 1;
                    eventData.push(Game.player1ChainScore);
                    eventData.push(Game.player1ChainMult);
                    break;
                case 2:
                    Game.player2ChainScore += matchPoints;
                    Game.player2ChainMult += 1;
                    eventData.push(Game.player2ChainScore);
                    eventData.push(Game.player2ChainMult);
                    break;
            }
            
            if (Game.animating)
            {   // wait until finished
                var timer = window.setInterval(function()
                {
                    if (!Game.animating)
                    {
                        window.clearInterval(timer);
                        
                        Game.eventTarget.trigger('matches:remove', eventData);
                        Game.Grid.fillSpace(matchData);
                    }
                }, 10);
            }
            else
            {
                Game.eventTarget.trigger('matches:remove', eventData);
                Game.Grid.fillSpace(matchData);
            }
        },
        
        fillSpace: function(matchData)
        {
            var newSquares = [];
            
            for (var gridKey in matchData)
            {   var currSquare = matchData[gridKey].square;
                
                // no time to implement gravity, alas
                //currSquare.gravDir = currSquare.quark.gravDir;
                
                // for now new quarks will just appear where the old ones were
                currSquare.quark = Quark.getRandomQuark();
                newSquares.push(currSquare);
            }
            
            if (Game.animating)
            {   // wait until finished
                var timer = window.setInterval(function()
                {
                    if (!Game.animating)
                    {
                        window.clearInterval(timer);
                        
                        Game.eventTarget.trigger('board:newQuarks', [newSquares]);
                        Game.Grid.checkDoChains(newSquares);
                    }
                }, 10);
            }
            else
            {
                Game.eventTarget.trigger('board:newQuarks', [newSquares]);
                Game.Grid.checkDoChains(newSquares);
            }
        },
        
        checkDoChains: function(newSquares)
        {
            var matchData = Game.Grid.getMatchDataForSquares(newSquares);
            
            if (!Object.keys(matchData).length) // no matches found, board is stable, score chain is finished, and turn can change
            {
                Game.movesMade++;
                
                var eventData = [Game.turn];
                
                switch (Game.turn)
                {
                    case 1:
                        Game.turn = 2;
                        Game.player1Score += Game.player1ChainScore * Game.player1ChainMult;
                        Game.player1ChainScore = 0;
                        Game.player1ChainMult = 0;
                        
                        eventData.push(Game.turn);
                        eventData.push(Game.player1Score);
                        break;
                    case 2:
                        Game.turn = 1;
                        Game.player2Score += Game.player2ChainScore * Game.player2ChainMult;
                        Game.player2ChainScore = 0;
                        Game.player2ChainMult = 0;
                        
                        eventData.push(Game.turn);
                        eventData.push(Game.player2Score);
                        break;
                }
                
                if (Game.animating)
                {   // wait until finished
                    var timer = window.setInterval(function()
                    {
                        if (!Game.animating)
                        {
                            window.clearInterval(timer);
                            
                            Game.eventTarget.trigger('board:stable', eventData);
                            if (Game.movesMade > Game.maxMoves)
                            {
                                Game.Over();
                            }
                        }
                    }, 10);
                }
                else
                {
                    Game.eventTarget.trigger('board:stable', eventData);
                    if (Game.movesMade > Game.maxMoves)
                    {
                        Game.Over();
                    }
                }
            }
            else  // do another event loop
            {
                Game.Grid.removeMatches(matchData);
            }
        },
        
        checkAnyMatchesTo: function(currSquare)
        {
            var hMatches = 1 + this.findMatchesTo(currSquare, Direction.left) + this.findMatchesTo(currSquare, Direction.right);
            if (hMatches >= 3)
                return true;
           
            var vMatches = 1 + this.findMatchesTo(currSquare, Direction.up) + this.findMatchesTo(currSquare, Direction.down);
            if (vMatches >= 3)
                return true;
           
            return false;
        },
        
        getMatchDataForSquares: function(squaresToMatch)
        {
            var rowMatches = [];
            var hMatchSquares = [];
            
            var colMatches = [];
            var vMatchSquares = [];
            
            squaresToMatch.forEach(function(currSquare)
            {
                var numMatchesToLeft = Game.Grid.findMatchesTo(currSquare, Direction.left);
                var numMatchesToRight = Game.Grid.findMatchesTo(currSquare, Direction.right);
                var numMatchesUp = Game.Grid.findMatchesTo(currSquare, Direction.up);
                var numMatchesDown = Game.Grid.findMatchesTo(currSquare, Direction.down);
                
                if (1 + numMatchesToLeft + numMatchesToRight >= 3)
                {
                    var rowMatch = [currSquare]; // start with this square
                    rowMatch = rowMatch.concat(Game.Grid.getNumSquaresFrom(numMatchesToLeft, currSquare.squareLeft, Direction.left));
                    rowMatch = rowMatch.concat(Game.Grid.getNumSquaresFrom(numMatchesToRight, currSquare.squareRight, Direction.right))
                    
                    rowMatches.push(rowMatch);
                    hMatchSquares = hMatchSquares.concat(rowMatch);
                }
                if (1 + numMatchesUp + numMatchesDown >= 3)
                {
                    var colMatch = [currSquare]; // start with this square
                    colMatch = colMatch.concat(Game.Grid.getNumSquaresFrom(numMatchesUp, currSquare.squareAbove, Direction.up));
                    colMatch = colMatch.concat(Game.Grid.getNumSquaresFrom(numMatchesDown, currSquare.squareBelow, Direction.down));
                    
                    colMatches.push(colMatch);
                    vMatchSquares = vMatchSquares.concat(colMatch);
                }
                
                //if (1 + matchesLeftB + matchesRightB >= 3)
                //{
                //    horizontalMatchSquares.concat(this.getNumSquaresFrom(matchesLeftB, squareB, Direction.left));
                //    horizontalMatchSquares.concat(this.getNumSquaresFrom(matchesRightB, squareB, Direction.right));
                //}
                //if (1 + matchesUpB + matchesDownB >= 3)
                //{
                //    verticalMatchSquares.concat(this.getNumSquaresFrom(matchesUpB, squareB, Direction.up));
                //    verticalMatchSquares.concat(this.getNumSquaresFrom(matchesDownB, squareB, Direction.down));
                //}
            });
            
            var matchData = {};
            
            hMatchSquares.forEach(function(currSquare)
            {
                matchData[currSquare.gridKey] = new Game.MatchDatum(currSquare, Direction.horizontal);
            });
            
            vMatchSquares.forEach(function(currSquare)
            {
                if (currSquare.gridKey in matchData)
                {
                    matchData[currSquare.gridKey].orientation = Direction.horizontal | Direction.vertical;
                }
                else
                {
                    matchData[currSquare.gridKey] = new Game.MatchDatum(currSquare, Direction.vertical);
                }
            });
            
            // we'll just tuck these in there, too
            // maybe useful for hypothetical implementation of gravity some day
            if (rowMatches.length)
                matchData['rowMatches'] = rowMatches;
            if (colMatches.length)
                matchData['colMatches'] = colMatches;
            
            return matchData;
        },
        // returns array of squares of length `number` starting from `currSquare` and going in `direction` on the grid
        getNumSquaresFrom: function(number, currSquare, direction)
        {
            if (number <= 0 || currSquare == null) // passed 0 or over the edge of the grid
                return [];  // return empty array
            
            var nextSquare = currSquare.neighboorInDir(direction);
            
            var arrOfSquares;
            number--;
            
            if (number)
            {
                arrOfSquares = this.getNumSquaresFrom(number, nextSquare, direction);
            }
            else
                arrOfSquares = [];
            
            arrOfSquares.push(currSquare);
            
            return arrOfSquares;
        },
        
        findMatchesTo: function(currSquare, direction)
        {
            var nextSquare = currSquare.neighboorInDir(direction);
            
            
            if (nextSquare == null || currSquare.quark != nextSquare.quark)
                return 0;
            
            return 1 + this.findMatchesTo(nextSquare, direction);
        }
    },
    
    // end game
    Over: function()
    {
        if (Game.player1Score == Game.player2Score)
        {
            Game.eventTarget.trigger('gameOver', [0]);
        }
        else if (Game.player1Score > Game.player2Score)
        {
            Game.eventTarget.trigger('gameOver', [1]);
        }
        else
        {
            Game.eventTarget.trigger('gameOver', [2]);
        }
    },
    
    //// MatchDatum object constructor
    MatchDatum: function(square, orientation)
    {
        Object.defineProperty(this, 'square', { value: square, writeable: true, enumerable: true });
        Object.defineProperty(this, 'orientation', { value: orientation, writeable: true, enumerable: true });
    }
}

//// Quark types
const Quark =
{
    RedLeft:
    {
        gravDir: Direction.left,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-left'
        //classRing:  "ring-red",
        //classArrow: "arrow-left"
    },
    BlueLeft:
    {
        gravDir: Direction.left,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-left'
    },
    RedUp:
    {
        gravDir: Direction.up,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-up'
    },
    BlueUp:
    {
        gravDir: Direction.up,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-up'
    },
    RedRight:
    {
        gravDir: Direction.right,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-right'
    },
    BlueRight:
    {
        gravDir: Direction.right,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-right'
    },
    RedDown:
    {
        gravDir: Direction.down,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-down'
    },
    BlueDown:
    {
        gravDir: Direction.down,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-down'
    },
    
    numQuarkTypes: 8,
    
    getRandomQuark: function()
    {
        var quarks = Object.keys(this);
        
        var randomIndex = Math.floor(Math.random() * this.numQuarkTypes);
        return Quark[quarks[randomIndex]];
    }
};

//// Square object constructor
function Square(x, y)
{
    Object.defineProperty(this, 'x', { value: x, enumerable: true });
    Object.defineProperty(this, 'y', { value: y, enumerable: true });
    
    Object.defineProperty(this, 'quark', { value: null, writable: true, enumerable: true });
    
    Object.defineProperty(this, 'gravDir', { value: null, writable: true, enumerable: true });
    Object.defineProperty(this, 'gravStrength', { value: null, writable: true, enumerable: true });
    
    this.neighboorInDir = function(direction)
    {
        switch (direction)
        {
            case Direction.up:
                return this.squareAbove;
                break;
            case Direction.down:
                return this.squareBelow;
                break;
            case Direction.left:
                return this.squareLeft;
                break;
            case Direction.right:
                return this.squareRight;
                break;
        }
    }
};
//// add some 'get adjacent square' properties to Square objects
// evaluates to null when looking beyond edge of Grid
Object.defineProperty(Square.prototype, 'squareAbove',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x, this.y-1);
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareBelow',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x, this.y+1);
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareLeft',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x-1, this.y);
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareRight',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x+1, this.y);
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'gridKey',
{
    get: function()
    {
        return Game.Grid.makeGridKey(this.x, this.y);
    },
    enumerable: true
});


//// command-line only stuff for testing purposes
//if (typeof process != 'undefined')
//{    
//    console.log(Game.Grid.getSquare(5,3).neighboorInDir(Direction.up));
//}
