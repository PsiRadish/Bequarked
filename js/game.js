// Kyle Fiegener
// BEQUARKED

/**
 * @fileOverview game.js is the shit
 */

//// Direction enum
/**
 * @namespace
 * @description Direction enum.
 */
var Direction = 
{
    // None:       0,
    //Left:       0,
    //Right:      1,
    //Up:         2,
    //Down:       3
    /** @constant */
    Left:   { someValue: 1 },
    /** @constant */
    Right:  { someValue: 2 },
    /** @constant */
    Up:     { someValue: 3 },
    /** @constant */
    Down:   { someValue: 4 }
};
Direction.Left.opposite  = Direction.Right;
Direction.Right.opposite = Direction.Left;
Direction.Up.opposite    = Direction.Down;
Direction.Down.opposite  = Direction.Up;

Direction.getOpposite = function(dir)
{
    switch (dir)
    {
     case Direction.Left:
        return Direction.Right;
     case Direction.Right:
        return Direction.Left;
     case Direction.Up:
        return Direction.Down;
     case Direction.Down:
        return Direction.Up;
    }
};

//// Alignment enum
var Alignment =
{
    None:        0,
    Vertical:    1, // Vertical and horizontal are combineable flags, for when a single
    Horizontal: 16  // quark is part of a vertical and horizontal match at the same time.
};

/**
 * @namespace
 * @description Global game state information and methods.
 */
var Game = 
{
    // the DOM element all trigger() calls will be made on, passed in through init()
    eventTarget: null,
    
    EventType:
    {
        GameStart:          "game:start",
        GameOver:           "game:over",
        BoardSwapSuccess:   "board:swapSuccess",
        BoardSwapFail:      "board:swapFail",
        BoardRemoveMatches: "board:removeMatches",
        BoardRemoveLine:    "board:removeLine",
        BoardNewQuarks:     "board:newQuarks",
        BoardGravity:       "board:gravity",
        BoardGravityBomb:   "board:gravityBomb",
        BoardStable:        "board:stable",
        FeedbackGravWait:   "feedback:gravityWait", // ?
        FeedbackLineWait:   "feedback:lineWait"     // ?
    },
    
    /**
     * This method should be called before any other game logic is executed.
     * @param $eTarget The jQuery object to receive all events generated by the game.
     * @todo: jQuery object to receive events on as well, to replace window.setInterval and its endlessly nesting function calls
     */
    init: function($eTarget)
    {
        this.eventTarget = $eTarget;
        
        // iterate through all squares and fill them with quarks
        for (var gridKey in this.Grid.squares)
        {
            var currSquare = this.Grid.squares[gridKey];
            
            // fill in square with random quark
            currSquare.quark = Quark.getRandomQuark();
            
            // check if this random quark causes any matches
            // (only need to check up and left because we're filling in from those directions)
            while (this.Grid.numMatchesTo(currSquare, Direction.Left) >= 2 || this.Grid.numMatchesTo(currSquare, Direction.Up) >= 2)
            {   // get a new random quark
                currSquare.quark = Quark.getRandomQuark();
            }
        }
        
        this.eventTarget.trigger(Game.EventType.GameStart, [Game.Grid.squares]);
    },
    
    animating:  false, // input ignored and game logic paused while true
    turn:       1,
    
    player1Score:       0,
    player1ChainScore:  0,
    player1ChainMult:   0,
    
    // player2Score:       0,
    // player2ChainScore:  0,
    // player2ChainMult:   0,
    
    movesMade:  0,
    maxMoves:   6, // after `maxMoves` moves between both players the game is over
    
    //matchSquares: null,
    
    matchGroups: [],
    
    gravHolesAll: {},
    gravHolesDir: [{}, {}, {}, {}],
    
    gravCumulation: [0, 0, 0, 0],
    gravPriority:   [0, 1, 2, 3],
    
    gravBombs: [],
    
    spawnSquares: [],
    
    dirtySquares: [],
    
    Grid:
    {
        squares:
        {   // Cleverness or whimsy? You decide!
            0x00: new Square(0, 0,  0x00),
            0x10: new Square(1, 0,  0x10),
            0x20: new Square(2, 0,  0x20),
            0x30: new Square(3, 0,  0x30),
            0x40: new Square(4, 0,  0x40),
            0x50: new Square(5, 0,  0x50),
            0x60: new Square(6, 0,  0x60),
            0x70: new Square(7, 0,  0x70),
            
            0x01: new Square(0, 1,  0x01),
            0x11: new Square(1, 1,  0x11),
            0x21: new Square(2, 1,  0x21),
            0x31: new Square(3, 1,  0x31),
            0x41: new Square(4, 1,  0x41),
            0x51: new Square(5, 1,  0x51),
            0x61: new Square(6, 1,  0x61),
            0x71: new Square(7, 1,  0x71),
            
            0x02: new Square(0, 2,  0x02),
            0x12: new Square(1, 2,  0x12),
            0x22: new Square(2, 2,  0x22),
            0x32: new Square(3, 2,  0x32),
            0x42: new Square(4, 2,  0x42),
            0x52: new Square(5, 2,  0x52),
            0x62: new Square(6, 2,  0x62),
            0x72: new Square(7, 2,  0x72),
            
            0x03: new Square(0, 3,  0x03),
            0x13: new Square(1, 3,  0x13),
            0x23: new Square(2, 3,  0x23),
            0x33: new Square(3, 3,  0x33),
            0x43: new Square(4, 3,  0x43),
            0x53: new Square(5, 3,  0x53),
            0x63: new Square(6, 3,  0x63),
            0x73: new Square(7, 3,  0x73),
            
            0x04: new Square(0, 4,  0x04),
            0x14: new Square(1, 4,  0x14),
            0x24: new Square(2, 4,  0x24),
            0x34: new Square(3, 4,  0x34),
            0x44: new Square(4, 4,  0x44),
            0x54: new Square(5, 4,  0x54),
            0x64: new Square(6, 4,  0x64),
            0x74: new Square(7, 4,  0x74),
            
            0x05: new Square(0, 5,  0x05),
            0x15: new Square(1, 5,  0x15),
            0x25: new Square(2, 5,  0x25),
            0x35: new Square(3, 5,  0x35),
            0x45: new Square(4, 5,  0x45),
            0x55: new Square(5, 5,  0x55),
            0x65: new Square(6, 5,  0x65),
            0x75: new Square(7, 5,  0x75),
            
            0x06: new Square(0, 6,  0x06),
            0x16: new Square(1, 6,  0x16),
            0x26: new Square(2, 6,  0x26),
            0x36: new Square(3, 6,  0x36),
            0x46: new Square(4, 6,  0x46),
            0x56: new Square(5, 6,  0x56),
            0x66: new Square(6, 6,  0x66),
            0x76: new Square(7, 6,  0x76),
            
            0x07: new Square(0, 7,  0x07),
            0x17: new Square(1, 7,  0x17),
            0x27: new Square(2, 7,  0x27),
            0x37: new Square(3, 7,  0x37),
            0x47: new Square(4, 7,  0x47),
            0x57: new Square(5, 7,  0x57),
            0x67: new Square(6, 7,  0x67),
            0x77: new Square(7, 7,  0x77)
        },
        
        // Encode x and y coordinates into fancy(/whimsical) hex byte key
        makeGridKey: function(x, y)
        {
            return (x << 4) | y;
        },
        
        getSquare: function(x, y)
        {
            var key = this.makeGridKey(x, y);
            
            if (!(key in this.squares))
                return null;
            
            return this.squares[key];
        },
        
        checkAnyMatchesTo: function(currSquare)
        {
            var hMatches = 1 + this.numMatchesTo(currSquare, Direction.Left) + this.numMatchesTo(currSquare, Direction.Right);
            if (hMatches >= 3)
                return true;
           
            var vMatches = 1 + this.numMatchesTo(currSquare, Direction.Up) + this.numMatchesTo(currSquare, Direction.Down);
            if (vMatches >= 3)
                return true;
           
            return false;
        },
        
        // returns array of squares of length `number` starting from `currSquare` and going in `direction` on the grid
        getNumSquaresFrom_InDir: function(number, currSquare, direction)
        {
            if (number <= 0 || currSquare == null) // passed 0 or over the edge of the grid
                return [];  // return empty array
            
            var nextSquare = currSquare.neighborInDir(direction);
            
            var arrOfSquares;
            number--;
            
            if (number)
            {
                arrOfSquares = this.getNumSquaresFrom_InDir(number, nextSquare, direction);
            }
            else
                arrOfSquares = [];
            
            arrOfSquares.push(currSquare);
            
            return arrOfSquares;
        },
        // returns array of squares from `currSquare` to end of grid going in `direction`
        getAllSquaresFrom_InDir: function(currSquare, direction)
        {
            return Game.Grid.getNumSquaresFrom_InDir(8, currSquare, direction);
        },
        
        numMatchesTo: function(currSquare, direction)
        {
            var nextSquare = currSquare.neighborInDir(direction);
            
            
            if (nextSquare == null || currSquare.quark != nextSquare.quark)
                return 0;
            
            return 1 + this.numMatchesTo(nextSquare, direction);
        }
    },
    
    // swapQuarks â€“ called from view.js
    swapQuarks: function(squareA, squareB)
    {
        var quarkA = squareA.quark;
        var quarkB = squareB.quark;
        
        if (quarkA == quarkB) // switching identical quarks will never produce a match
        {
            Game.eventTarget.trigger(Game.EventType.BoardSwapFail, [squareA, squareB]);
            
            return;
        }
        
        // Temporarily swap quarks to check if a match is produced
        squareA.quark = quarkB;
        squareB.quark = quarkA;
        
        if (!(Game.Grid.checkAnyMatchesTo(squareA) || Game.Grid.checkAnyMatchesTo(squareB)))
        {   // Bust, switch back.
            squareA.quark = quarkA;
            squareB.quark = quarkB;
            
            Game.eventTarget.trigger(Game.EventType.BoardSwapFail, [squareA, squareB]);
            
            return;
        }
        
        //var squaresAandB = [squareA, squareB];
        squareA.dirty = true;
        squareB.dirty = true;
        //Game.dirtySquares.push(squareA, squareB);
        
        Game.eventTarget.trigger(Game.EventType.BoardSwapSuccess, [squareA, squareB]);
        
        //Game.processChangedSquares(squaresAandB);
        Game.processChangedSquares();
    },
    
    processChangedSquares: function()
    {
        var changedSquares = Game.dirtySquares.splice(); // shallow copy
        var matchSquares = Game.getMatchesForSquares(changedSquares);
        
        if (matchSquares.length > 0)
        {
            Game.removeMatches(matchSquares);
        }
        else // no matches found, board is stable, score chain is finished and can be added 
        {
            Game.movesMade++;
            
            //var eventData = [Game.turn];
            Game.player1Score += Game.player1ChainScore * Game.player1ChainMult;
            Game.player1ChainScore = 0;
            Game.player1ChainMult = 0;
            
            // eventData.push(Game.turn);
            // eventData.push(Game.player1Score);
            
            var eventData = [Game.player1Score];
            
          /*switch (Game.turn)
            {
                case 1:
                    //Game.turn = 2;
                    Game.player1Score += Game.player1ChainScore * Game.player1ChainMult;
                    Game.player1ChainScore = 0;
                    Game.player1ChainMult = 0;
                    
                    eventData.push(Game.turn);
                    eventData.push(Game.player1Score);
                    break;
                case 2:
                    //Game.turn = 1;
                    Game.player2Score += Game.player2ChainScore * Game.player2ChainMult;
                    Game.player2ChainScore = 0;
                    Game.player2ChainMult = 0;
                    
                    eventData.push(Game.turn);
                    eventData.push(Game.player2Score);
                    break;
            }*/
    
            // TODO: Replace timer loop with an event listener for some sort of "spawn animation done" event from the view
            if (Game.animating)
            {   // wait until finished
                var timer = window.setInterval(function()
                {
                    if (!Game.animating)
                    {
                        window.clearInterval(timer);
                        
                        Game.eventTarget.trigger(Game.EventType.BoardStable, eventData);
                        if (Game.movesMade >= Game.maxMoves)
                        {
                            Game.Over();
                        }
                    }
                }, 10);
            }
            else
            {
                Game.eventTarget.trigger(Game.EventType.BoardStable, eventData);
                if (Game.movesMade >= Game.maxMoves)
                {
                    Game.Over();
                }
            }
        }
    },
    
    // getMatchesForSquares
    getMatchesForSquares: function(squaresToMatch)
    {
        var matchSquares = [];
        
        squaresToMatch.forEach(function(currSquare)
        {
            currSquare.matchAlignment = Alignment.None; // reset matchAlignment
            
            var matches = false;
            
            var numMatchesToLeft = Game.Grid.numMatchesTo(currSquare, Direction.Left);
            var numMatchesToRight = Game.Grid.numMatchesTo(currSquare, Direction.Right);
            
            var numMatchesAbove = Game.Grid.numMatchesTo(currSquare, Direction.Up);
            var numMatchesBelow = Game.Grid.numMatchesTo(currSquare, Direction.Down);
            
            [Alignment.Horizontal, Alignment.Vertical].forEach(function(lineAlignment)
            {
                if ((lineAlignment === Alignment.Horizontal && 1 + numMatchesToLeft + numMatchesToRight >= 3) ||
                    (lineAlignment === Alignment.Vertical   && 1 + numMatchesAbove + numMatchesBelow >= 3))
                {
                    matches = true;
                    
                    var lineMatch = [currSquare]; // start with current square
                    
                    if (lineAlignment == Alignment.Horizontal)
                    {    
                        lineMatch = lineMatch.concat(Game.Grid.getNumSquaresFrom_InDir(numMatchesToLeft, currSquare.squareLeft, Direction.Left));
                        lineMatch = lineMatch.concat(Game.Grid.getNumSquaresFrom_InDir(numMatchesToRight, currSquare.squareRight, Direction.Right));
                    }
                    else // Alignment.Vertical
                    {
                        lineMatch = lineMatch.concat(Game.Grid.getNumSquaresFrom_InDir(numMatchesAbove, currSquare.squareAbove, Direction.Up));
                        lineMatch = lineMatch.concat(Game.Grid.getNumSquaresFrom_InDir(numMatchesBelow, currSquare.squareBelow, Direction.Down));
                    }
                    
                    var matchGravDir = currSquare.quark.gravDir;
                    var matchGravStrength = 0;
                    
                    // gravity direction parallel to match alignment
                    if ((lineAlignment === Alignment.Horizontal && (matchGravDir == Direction.Right || matchGravDir == Direction.Left)) ||
                        (lineAlignment === Alignment.Vertical   && (matchGravDir == Direction.Up    || matchGravDir == Direction.Down)))
                    {
                        matchGravStrength = lineMatch.length;
                    }
                    else // gravity direction perpendicular to match alignment
                    {
                        matchGravStrength = 1;
                    }
                    
                    // Probably won't use this...
                    // Game.gravCumulation[matchGravDir] += matchGravStrength; // increase priority for this grav direction
                    
                    // Create MatchGroup object that will be used later for gravity resolution
                    var matchGroup = new Game.MatchGroup();
                    var matchGroupIndex = -1;
                    
                    // store this match alignment in the square
                    lineMatch.forEach(function(lineSquare)
                    {
                        lineSquare.matchAlignment |= lineAlignment;
                        
                        // set a dirty flag on the square
                        lineSquare.dirty = true;
                        /*if (!lineSquare.dirty)
                        {
                            lineSquare.dirty = true;
                            Game.dirtySquares.push(lineSquare);
                        }*/
                        
                        lineSquare.gravDir = matchGravDir;
                        // if square already has a gravStrength, only change if new one is larger
                        lineSquare.gravStrength = Math.max(lineSquare.gravStrength, matchGravStrength);
                        
                        // store this square in the MatchGroup
                        //matchGroup.squares[lineSquare.gridKey] = lineSquare;
                        matchGroup.squares.push(lineSquare);
                                                
                        if (lineSquare.matchGroupIndex != -1) // if this square is already in a match group
                        {
                            if (matchGroupIndex != -1) // This shouldn't be possible.
                                console.log("DOUBLE ASSIGNING MATCH GROUP WHAAAT?");
                            
                            // store index of existing MatchGroup to merge with later
                            matchGroupIndex = lineSquare.matchGroupIndex;
                        }
                    });
                    //lineMatch.sort(Square.compareFunction);
                    
                    // either add matchGroup to Game.matchGroups, or merge with an existing group in Game.matchGroups
                    if (matchGroupIndex == -1) // if matchGroupIndex wasn't assigned in the forEach above, then matchGroup is new
                    {
                        matchGroup.assignIndexToSquares(Game.matchGroups.length);
                        Game.matchGroups.push(matchGroup);
                    }
                    else // merge with existing MatchGroup
                    {
                        matchGroup.assignIndexToSquares(matchGroupIndex);
                        
                        // merge objects (using jQuery)
                        //$.extend(Game.matchGroups[matchGroupIndex].squares, matchGroup.squares);
                        
                        // merge arrays
                        //Game.matchGroups[matchGroupIndex].squares = Game.matchGroups[matchGroupIndex].squares.union(matchGroup.squares); // using array extension in array.js
                        Game.matchGroups[matchGroupIndex].squares = Square.Array.union(Game.matchGroups[matchGroupIndex].squares, matchGroup.squares);
                    }
                    
                    // rowMatches.push(lineMatch);
                    matchSquares = matchSquares.concat(lineMatch);
                }
            });
            
            // when dirty square is confirmed to have no matches, remove dirty flag 
            if (!matches && currSquare.dirty)
            {
                currSquare.dirty = false;
                //Game.dirtySquares.remove(currSquare);
            }
        });
        
        // var matchData = {};
        
        // hMatchSquares.forEach(function(currSquare)
        // {
        //     matchData[currSquare.gridKey] = new Game.MatchDatum(currSquare, Alignment.Horizontal);
        // });
        
        // vMatchSquares.forEach(function(currSquare)
        // {
        //     if (currSquare.gridKey in matchData)
        //     {
        //         matchData[currSquare.gridKey].orientation = Alignment.Horizontal | Alignment.Vertical;
        //     }
        //     else
        //     {
        //         matchData[currSquare.gridKey] = new Game.MatchDatum(currSquare, Alignment.Vertical);
        //     }
        // });
        
        //return matchData;
        //return hMatchSquares.concat(vMatchSquares);
        return matchSquares;
    },
    
    //removeMatches: function(matchData)
    removeMatches: function(matchSquares)
    {        
        // var matchPoints = Object.keys(matchData).length * 100;
        var matchPoints = matchSquares.length * 100;
        
        // set square quarks to null
        matchSquares.forEach(function(currSquare)
        {
            currSquare.quark = null;
            
            if (currSquare.state == Square.State.Quark) // state hasn't been updated yet
            {
                // get adjacent square in direction opposite to gravDir
                //var oppSquare = currSquare.neighborInDir(Direction.getOpposite(currSquare.gravDir));
                var oppSquare = currSquare.neighborInDir(currSquare.gravDir.opposite);
                if (oppSquare != null && oppSquare.gravDir === currSquare.gravDir.opposite)
                {
                    //Game.gravBombs[currSquare.gridKey] = currSquare;
                    //Game.gravBombs[oppSquare.gridKey] = oppSquare;
                    Game.gravBombs.push([currSquare, oppSquare]);
                    
                    currSquare.state = Square.State.GravityBomb;
                    oppSquare.state = Square.State.GravityBomb;
                    
                    // remove grav bombs from match groups
                    if (currSquare.matchGroupIndex != -1) // this check might be redundant
                    {
                        //delete Game.matchGroups[currSquare.matchGroupIndex].squares[currSquare.gridKey];
                        Game.matchGroups[currSquare.matchGroupIndex].squares.remove(currSquare);
                        currSquare.matchGroupIndex = -1;
                    }
                    if (oppSquare.matchGroupIndex != -1) // this check might be redundant
                    {
                        //delete Game.matchGroups[oppSquare.matchGroupIndex].squares[oppSquare.gridKey];
                        Game.matchGroups[oppSquare.matchGroupIndex].squares.remove(oppSquare);
                        oppSquare.matchGroupIndex = -1;
                    }
                }
                else
                {
                    Game.gravHolesAll[currSquare.gridKey] = currSquare;
                    Game.gravHolesDir[currSquare.gravDir][currSquare.gridKey] = currSquare;
                    
                    currSquare.state = Square.State.Gravity;
                }
            }
        });
        Game.matchGroups.sort(Game.MatchGroup.compareFunction);
        
        // var eventData = [matchData];
        var eventData = [Square.Array.clone(matchSquares)];
    
        // deep copy gravBombs
        var gravBombsClone = Game.gravBombs.filter(function(gravBomb){ return Square.Array.clone(gravBomb) });
        eventData.push(gravBombsClone);
        
        Game.player1ChainScore += matchPoints;
        Game.player1ChainMult += 1;
        eventData.push(Game.player1ChainScore);
        eventData.push(Game.player1ChainMult);
        
        // switch (Game.turn)
        // {
        //     case 1:
        //         Game.player1ChainScore += matchPoints;
        //         Game.player1ChainMult += 1;
        //         eventData.push(Game.player1ChainScore);
        //         eventData.push(Game.player1ChainMult);
        //         break;
        //     case 2:
        //         Game.player2ChainScore += matchPoints;
        //         Game.player2ChainMult += 1;
        //         eventData.push(Game.player2ChainScore);
        //         eventData.push(Game.player2ChainMult);
        //         break;
        // }
    
        // TODO: Replace timer loop with an event listener for some sort of "swap animation done" event from the view
        if (Game.animating)
        {   // wait until finished
            var timer = window.setInterval(function()
            {
                if (!Game.animating)
                {
                    window.clearInterval(timer);
                    
                    Game.eventTarget.trigger(Game.EventType.BoardRemoveMatches, eventData);
                    // Game.spawnNewQuarks(matchData);
                    // Game.spawnNewQuarks(matchSquares);
                    Game.processGravity();
                }
            }, 10);
        }
        else
        {
            Game.eventTarget.trigger(Game.EventType.BoardRemoveMatches, eventData);
            // Game.spawnNewQuarks(matchData);
            // Game.spawnNewQuarks(matchSquares);
            Game.processGravity();
        }
    },
    
    processGravity: function()
    {
        //if (Object.keys(Game.gravHolesAll).length == 0 && Object.keys(Game.gravBombs).length == 0)
        if (Game.matchGroups.length == 0 && Game.gravBombs.length == 0)
        {
            Game.spawnNewQuarks();
            Game.spawnSquares = [];
        }
        else
        {
            console.log('==processGravity==');
            console.log('num matchGroups', Game.matchGroups.length);
            console.log('num gravBombs', Game.gravBombs.length);
            console.log();
            
            //// Standard Gravity
            if (Game.matchGroups.length > 0)
            {
                var gravSquares = [];
                Game.matchGroups.forEach(function(matchGroup)
                {
                    //for (var i = 0; i < matchGroup.squares.length; i++)
                    var goodToGrav = matchGroup.squares.every(function(square)
                    {   
                        //var pullSquare = square.neighborInDir(Direction.getOpposite(square.gravDir));
                        var pullSquare = square.neighborInDir(square.gravDir.opposite);
                        if (!pullSquare.inSameGroupAs(square)) // this square directly pulls on a square outside the match group
                        {
                            //var checkSquares = Game.Grid.getAllSquaresFrom_InDir(pullSquare, Direction.getOpposite(square.gravDir));
                            var checkSquares = Game.Grid.getAllSquaresFrom_InDir(pullSquare, square.gravDir.opposite);
                            return checkSquares.every(function(checkSquare)
                            {
                                return (checkSquare.gravDir == null || checkSquare.gravDir == square.gravDir);
                            });
                        }
                        return true;
                    });
                    
                    if (goodToGrav)
                    {   // loop through again and set gravity
                        matchGroup.squares.forEach(function(square)
                        {
                            var gravSquaresTemp = [square];
                            
                            //var pullSquare = square.neighborInDir(Direction.getOpposite(square.gravDir));
                            var pullSquare = square.neighborInDir(square.gravDir.opposite);
                            if (!pullSquare.inSameGroupAs(square)) // this square directly pulls on a square outside the match group
                            {
                                //var setSquares = Game.Grid.getAllSquaresFrom_InDir(pullSquare, Direction.getOpposite(square.gravDir));
                                var setSquares = Game.Grid.getAllSquaresFrom_InDir(pullSquare, square.gravDir.opposite);
                                setSquares.forEach(function(setSquare)
                                {
                                    setSquare.gravDir = square.gravDir;
                                    setSquare.gravStrength += square.gravStrength;
                                    
                                    setSquare.dirty = true;
                                });
                                
                                gravSquaresTemp = gravSquaresTemp.concat(setSquares);
                            }
                            
                            //gravSquares = gravSquares.union(gravSquaresTemp);
                            gravSquares = Square.Array.union(gravSquares, gravSquaresTemp);
                        });
                        
                        Game.matchGroups.remove(matchGroup);
                    }
                });
                
                if (gravSquares.length > 0)
                {
                    //Game.dirtySquares = Game.dirtySquares.union(gravSquares); // merge gravSquares into dirties
                    
                    // deep copy gravSquares
                    var oldSquares = Square.Array.clone(gravSquares);
                    
                    var eventData = [oldSquares]; // will be sent to view for animating
                    
                    // start movin' quarks
                    gravSquares.forEach(function(currSquare, i)
                    {
                        var swapSquare = oldSquares[i].nth_NeighborInDir(currSquare.gravStrength, currSquare.gravDir.opposite);
                        
                        if (!swapSquare || !swapSquare.quark) // passed edge of grid or swapSquare has no quark
                        {
                            currSquare.quark = null;
                            currSquare.state = Square.State.Spawn;
                            Game.spawnSquares.push(currSquare);
                        }
                        else
                        {
                            currSquare.quark = swapSquare.quark;
                            currSquare.state = Square.State.Quark;
                        }
                        
                        currSquare.gravDir = null;
                        currSquare.gravStrength = 0;
                    });
                    
                    if (Game.animating)
                    {   // wait until finished
                        // TODO: Replace timer loop with an event listener for some sort of "gravity animation done" event from the view
                        var timer = window.setInterval(function()
                        {
                            if (!Game.animating)
                            {
                                window.clearInterval(timer);
                
                                Game.eventTarget.trigger(Game.EventType.BoardGravity, eventData);
                                Game.processGravity();
                            }
                        }, 10);
                    }
                    else
                    {
                        Game.eventTarget.trigger(Game.EventType.BoardGravity, eventData);
                        Game.processGravity();
                    }
                }
                else
                    console.log("Oh shit, didn't gravitize any matchGroups, gonna loop forever, NOOOOOOOO!!");
            }
            //// Gravity Bombs
            else
            {
                var bombedSquares = [];
                
                Game.gravBombs.forEach(function(gravBomb) // each gravBomb is an array of two squares
                {
                    var align = Math.abs(gravBomb[0].gridKey - gravBomb[1].gridKey); // will equal Alignment.Vertical or Alignment.Horizontal
                    
                    var x, y, direction;
                    // get coordinates of first square in line to be destroyed
                    switch (align)
                    {
                        case Alignment.Horizontal:
                            x = 0;
                            y = gravBomb[0].y;
                            direction = Direction.Right;
                            break;
                        case Alignment.Vertical:
                            x = gravBomb[0].x;
                            y = 0;
                            direction = Direction.Down;
                            break;
                        default:
                            throw "gravBomb alignment not horizontal or vertical, instead = " + align;
                    }
                    
                    var lineSquares = Game.Grid.getAllSquaresFrom_InDir(Game.Grid.getSquare(x, y), direction);
                    lineSquares.forEach(function(lineSquare)
                    {
                        lineSquare.quark = null;
                        lineSquare.dirty = true;
                        if (lineSquare.state != Square.State.Spawn) // square isn't already empty
                        {
                            lineSquare.state = Square.State.Spawn;
                            Game.spawnSquares.push(lineSquare);
                        }
                    });
                    
                    Square.Array.union(bombedSquares, lineSquares);
                });
    
                eventData = [Square.Array.clone(bombedSquares)];
                
                // deep copy gravBombs
                var gravBombsClone = Game.gravBombs.filter(function(gravBomb){ return Square.Array.clone(gravBomb) });
                eventData.push(gravBombsClone);
    
                if (Game.animating)
                {   // wait until finished
                    // TODO: Replace timer loop with an event listener for some sort of "gravity animation done" event from the view
                    timer = window.setInterval(function()
                    {
                        if (!Game.animating)
                        {
                            window.clearInterval(timer);
                
                            Game.eventTarget.trigger(Game.EventType.BoardGravityBomb, eventData);
                            Game.processGravity();
                        }
                    }, 10);
                }
                else
                {
                    Game.eventTarget.trigger(Game.EventType.BoardGravityBomb, eventData);
                    Game.processGravity();
                }
            }
            
            //// TEMPORARY
            // for now new quarks will just appear where the old ones were
            //Game.spawnSquares = Game.dirtySquares.slice(); // shallow copy
            //Game.gravHolesAll = {};
            //Game.gravHolesDir = [{}, {}, {}, {}];
            //Game.gravBombs = [];
            //Game.matchGroups = [];
            //
            //Game.processGravity();
        }
    },
    
    // spawnNewQuarks: function(matchData)
    spawnNewQuarks: function()
    {
        var fillSquares = Game.spawnSquares;
        
        fillSquares.forEach(function(currSquare)
        {
            currSquare.spawnQuark();
            //currSquare.quark = Quark.getRandomQuark();
            //currSquare.state = Square.State.Quark;
        });
        
        // TODO: Replace timer loop with an event listener for some sort of "gravity animation done" event from the view
        if (Game.animating)
        {   // wait until finished
            var timer = window.setInterval(function()
            {
                if (!Game.animating)
                {
                    window.clearInterval(timer);
                    
                    Game.eventTarget.trigger(Game.EventType.BoardNewQuarks, [Square.Array.clone(fillSquares)]);
                    //Game.processChangedSquares(fillSquares);
                    Game.processChangedSquares();
                }
            }, 10);
        }
        else
        {
            Game.eventTarget.trigger(Game.EventType.BoardNewQuarks, [Square.Array.clone(fillSquares)]);
            //Game.processChangedSquares(fillSquares);
            Game.processChangedSquares();
        }
    },
    
    // end game
    Over: function()
    {
        // if (Game.player1Score == Game.player2Score)
        // {
        //     Game.eventTarget.trigger(Game.EventType.GameOver, [0]);
        // }
        // else if (Game.player1Score > Game.player2Score)
        // {
        //     Game.eventTarget.trigger(Game.EventType.GameOver, [1]);
        // }
        // else
        // {
        //     Game.eventTarget.trigger(Game.EventType.GameOver, [2]);
        // }
        
        Game.eventTarget.trigger(Game.EventType.GameOver, [1]);
    },
    
    // EffectDatum object constructor
    EffectDatum: function(startSquare, alignment, length)
    {
        this.startSquare = startSquare;
        this.alignment = alignment;
        this.length = length;
    }
};
Game.MatchGroup = function()
{
    this.squares = []; // {};
};
Object.defineProperty(Game.MatchGroup.prototype, 'assignIndexToSquares',
{
    value: function(index)
    {
        //for (var gridKey in this.squares)
        this.squares.forEach(function(square)
        {
            //this[gridKey].matchGroupIndex = index;
            square.matchGroupIndex = index;
        });
    },
    enumerable: false
});
Object.defineProperty(Game.MatchGroup.prototype, 'totalGravStrength',
{
    get: function()
    {
        var total = 0;
        
        //for (var gridKey in this.squares)
        this.squares.forEach(function(square)
        {            
            //total += this[gridKey].gravStrength;
            total += square.gravStrength;
        });
        
        return total;
    },
    enumerable: false
});
Game.MatchGroup.compareFunction = function(groupA, groupB)
{
    //return groupA.totalGravStrength - groupB.totalGravStrength;
    return groupB.totalGravStrength - groupA.totalGravStrength; // sort descending
};

/**
 * Creates a new instance of class Square.
 * @class Represents a square on the grid.
 * @param x X coordinate of the square.
 * @param y Y coordinate of the square.
 * @param gridKey X and Y coordinates encoded in hex, used as the key into <code>Game.Grid.squares</code>.
 */
function Square(x, y, gridKey)
{
    Object.defineProperty(this, 'x', { value: x, enumerable: true });
    Object.defineProperty(this, 'y', { value: y, enumerable: true });
    Object.defineProperty(this, 'gridKey', { value: gridKey, enumerable: true });
    
    this.quark = null;
    
    this.gravDir = null;
    this.gravStrength = 0;
    // this.gravUp    = 0;
    // this.gravDown  = 0;
    // this.gravLeft  = 0;
    // this.gravRight = 0;
    this.matchAlignment = Alignment.None;
    this.matchGroupIndex = -1;
    this.state = 0; // Square.State.Spawn
    
    this._dirty = false;
}
// enum definition
Square.State =
{
    Spawn: 0,
    Quark: 1,
    Match: 2,
    Gravity: 3,
    GravityBomb: 4
};
/**
 * Flag for squares that have changed in some way and have not yet been checked for matches. Setting
 * to <code>true</code> automatically adds this square to <code>Game.dirtySquares</code>.
 * @type {boolean}
 * @name Square#dirty
 */
Object.defineProperty(Square.prototype, 'dirty',
{
    get: function()
    {
        return this._dirty;
    },
    set: function(newValue)
    {
        // current and new value both true
        if (this._dirty && newValue)
            return; // nothing to do
        
        // current value true and new value false
        if (this._dirty)
        {
            this._dirty = false;
            // remove from dirty squares list
            Game.dirtySquares.remove(this); // using Array extension in array.js
        }
        // current value false and new value true
        else if (newValue)
        {
            this._dirty = true;
            // add to dirty squares list
            Game.dirtySquares.push(this);
        }
    },
    enumerable: true
});
//// add some 'get adjacent square' properties to Square objects
Object.defineProperty(Square.prototype, 'squareAbove',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x, this.y-1); // evaluates to null when looking beyond edge of Grid
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareBelow',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x, this.y+1); // evaluates to null when looking beyond edge of Grid
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareLeft',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x-1, this.y); // evaluates to null when looking beyond edge of Grid
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareRight',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x+1, this.y); // evaluates to null when looking beyond edge of Grid
    },
    enumerable: true
});
Square.prototype.neighborInDir = function(direction)
{
    switch (direction)
    {
     case Direction.Up:
        return this.squareAbove;
        break;
     case Direction.Down:
        return this.squareBelow;
        break;
     case Direction.Left:
        return this.squareLeft;
        break;
     case Direction.Right:
        return this.squareRight;
        break;
    }
};
Square.prototype.nth_NeighborInDir = function(n, direction)
{
    if (n == 0)
        return this;
    
    var nextSquare = this.neighborInDir(direction);
    if (!nextSquare)
        return null;
    
    return nextSquare.nth_NeighborInDir(n-1, direction);
};
Square.prototype.spawnQuark = function()
{
    this.quark = Quark.getRandomQuark();
    this.state = Square.State.Quark;
    
    this.gravDir = null;
    this.gravStrength = 0;
    this.matchAlignment = Alignment.None;
    this.matchGroupIndex = -1;
};
// Returns true if this square and otherSquare have the same non-negative matchGroupIndex
Square.prototype.inSameGroupAs = function(otherSquare)
{
    return (this.matchGroupIndex != -1 && this.matchGroupIndex == otherSquare.matchGroupIndex);
};
// Checks all squares from this square to grid edge for following conditions:
// (this.gravDir == gravDir || this.gravDir == null)
// Returns true if all squares pass.
/*Square.prototype.checkGravityInDir = function(direction, gravDir)
{
    if (this.gravDir != null && this.gravDir != gravDir)
        return false;
    
    var nextSquare = this.neighborInDir(direction);
    return (!nextSquare || nextSquare.checkGravityInDir(direction, gravDir, gravStrength));
};
// Set gravStrength and gravDir on all squares from this square to grid edge
Square.prototype.setGravityInDir = function(direction, gravDir, gravStrength)
{
    this.gravDir = gravDir;
    this.gravStrength += gravStrength;
    
    var nextSquare = this.neighborInDir(direction);
    if (nextSquare)
    {
        nextSquare.setGravityInDir(direction, gravDir, gravStrength);
    }
};*/
// Returns whether this square and otherSquare have the same gridKey
Square.prototype.equals = function(otherSquare)
{
    return this.gridKey == otherSquare.gridKey;
};
// Returns a deep copy of this Square.
Square.prototype.clone = function()
{
    var clone = new Square(this.x, this.y, this.gridKey);
    clone.quark = this.quark;
    
    clone.gravDir = this.gravDir;
    clone.gravStrength = this.gravStrength;
    
    clone.matchAlignment = this.matchAlignment;
    clone.matchGroupIndex = this.matchGroupIndex;
    clone.state = this.state;
    
    clone._dirty = this._dirty;
    
    return clone;
};
/** 
 * @namespace
 */
Square.Array =
{
    /**
     * Returns a deep copy of the passed array of Square objects.
     * @param {Array.<Square>} squaresArray Array of Squares to deep copy.
     * @returns {Array.<Square>}
     */
    clone: function(squaresArray)
    {
        return squaresArray.filter(function(square){ return square.clone(); });
    },
    /**
     * Joins the two passed arrays of Square objects into one array with no duplicates.
     * @param {Array.<Square>} squaresArray1
     * @param {Array.<Square>} squaresArray2
     * @returns {Array.<Square>}
     */
    union: function(squaresArray1, squaresArray2)
    {
        var hash = {};
        
        // add both arrays into a hash by gridKey to eliminate duplicates
        for (var i = 0; i < squaresArray1.length; i++)
            hash[squaresArray1[i].gridKey] = squaresArray1[i];
        for (i = 0; i < squaresArray2.length; i++)
            hash[squaresArray2[i].gridKey] = squaresArray2[i];
        
        // convert back to an array
        var union = [];
        for (var k in hash)
        {
            union.push(hash[k]);
        }
        
        return union;
    }
};
// Comparison function for sorting arrays of squares. (Probably won't be used)
Square.compareFunction = function(squareA, squareB)
{
    return squareA.gridKey - squareB.gridKey;
};


//// Quark types
var Quark =
{
    RedLeft:
    {
        gravDir: Direction.Left,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-left'
    },
    BlueLeft:
    {
        gravDir: Direction.Left,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-left'
    },
    RedUp:
    {
        gravDir: Direction.Up,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-up'
    },
    BlueUp:
    {
        gravDir: Direction.Up,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-up'
    },
    RedRight:
    {
        gravDir: Direction.Right,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-right'
    },
    BlueRight:
    {
        gravDir: Direction.Right,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-right'
    },
    RedDown:
    {
        gravDir: Direction.Down,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-down'
    },
    BlueDown:
    {
        gravDir: Direction.Down,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-down'
    },
    
    NumQuarkTypes: 8,
    
    getRandomQuark: function()
    {
        var quarkTypes = Object.keys(this);
        
        var randomIndex = Math.floor(Math.random() * this.NumQuarkTypes);
        return Quark[quarkTypes[randomIndex]];
    }
};


//// command-line only stuff for testing purposes
//if (typeof process != 'undefined')
//{    
//    console.log(Game.Grid.getSquare(5,3).neighborInDir(Direction.Up));
//}
