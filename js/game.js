// Kyle Fiegener
// BEQUARKED

/**
 * @fileOverview game.js is the shit
 */

/**
 * @namespace
 * @description Direction enum.
 */
var Direction = 
{
    // None:       0,
    //Left:       0,
    //Right:      1,
    //Up:         2,
    //Down:       3
    /** @constant */
    Left:   { string: 'left' },
    /** @constant */
    Right:  { string: 'right' },
    /** @constant */
    Up:     { string: 'up' },
    /** @constant */
    Down:   { string: 'down' }
};
/** @constant */
Direction.Left.opposite  = Direction.Right;
/** @constant */
Direction.Right.opposite = Direction.Left;
/** @constant */
Direction.Up.opposite    = Direction.Down;
/** @constant */
Direction.Down.opposite  = Direction.Up;

/**
 * @namespace
 * @description Orientation flags. Can be |'d together for when a single quark is part of a vertical and horizontal match at the same time.
 * Also, the Alignment between any 2 adjacent Squares can be obtained by taking the absolute value of their gridKeys minused together.
 */
var Alignment =
{
    /** @constant */
    None:        0,
    /** @constant */
    Vertical:    1,
    /** @constant */
    Horizontal: 16
};

/**
 * @namespace
 * @description Global game state information and methods.
 */
var Game = 
{
    // the DOM element all trigger() calls will be made on, passed in through init()
    eventTarget: null,
    
    EventType:
    {
        GameStart:          "game:start",
        GameOver:           "game:over",
        BoardSwapSuccess:   "board:swapSuccess",
        BoardSwapFail:      "board:swapFail",
        BoardRemoveMatches: "board:removeMatches",
        BoardRemoveLine:    "board:removeLine",
        BoardNewQuarks:     "board:newQuarks",
        BoardGravity:       "board:gravity",
        BoardGravityBomb:   "board:gravityBomb",
        BoardStable:        "board:stable",
        FeedbackGravWait:   "feedback:gravityWait", // ?
        FeedbackLineWait:   "feedback:lineWait"     // ?
    },
    
    /**
     * This method should be called before any other game logic is executed.
     * @param $eTarget The jQuery object to receive all events generated by the game.
     * @todo: jQuery object to receive events on as well, to replace window.setInterval and its endlessly nesting function calls
     */
    init: function($eTarget)
    {
        this.eventTarget = $eTarget;
        
        // iterate through all squares and fill them with quarks
        for (var gridKey in this.Grid.squares)
        {
            var currSquare = this.Grid.squares[gridKey];
            
            // fill in square with random quark
            currSquare.quark = Quark.getRandomQuark();
            
            // check if this random quark causes any matches
            // (only need to check up and left because we're filling in from those directions)
            while (this.Grid.numMatchesTo(currSquare, Direction.Left) >= 2 || this.Grid.numMatchesTo(currSquare, Direction.Up) >= 2)
            {   // get a new random quark
                currSquare.quark = Quark.getRandomQuark();
            }
        }
        
        this.eventTarget.trigger(Game.EventType.GameStart, [Game.Grid.squares]);
    },
    
    animating:  false, // input ignored and game logic paused while true
    turn:       1,
    
    player1Score:       0,
    player1ChainScore:  0,
    player1ChainMult:   0,
    
    // player2Score:       0,
    // player2ChainScore:  0,
    // player2ChainMult:   0,
    
    movesMade:  0,
    maxMoves:   6, // after `maxMoves` moves between both players the game is over
    
    matchGroups: [],
    resolvedMatchGroups: {},
    
    gravBombs: [],
    
    spawnSquares: [],
    
    /**
     * List of squares to be checked by <code>Game.processChangedSquares()</code>.
     * Automatically updated by the Square class's <code>dirty</code> instance property.
     * @type {Array<Square>}
     */
    dirtySquares: [],
    
    /** @namespace */
    Grid:
    {   // Instantiate the game grid
        squares:
        {   // Cleverness or whimsy? You decide!
            0x00: new Square(0, 0,  0x00),
            0x10: new Square(1, 0,  0x10),
            0x20: new Square(2, 0,  0x20),
            0x30: new Square(3, 0,  0x30),
            0x40: new Square(4, 0,  0x40),
            0x50: new Square(5, 0,  0x50),
            0x60: new Square(6, 0,  0x60),
            0x70: new Square(7, 0,  0x70),
            
            0x01: new Square(0, 1,  0x01),
            0x11: new Square(1, 1,  0x11),
            0x21: new Square(2, 1,  0x21),
            0x31: new Square(3, 1,  0x31),
            0x41: new Square(4, 1,  0x41),
            0x51: new Square(5, 1,  0x51),
            0x61: new Square(6, 1,  0x61),
            0x71: new Square(7, 1,  0x71),
            
            0x02: new Square(0, 2,  0x02),
            0x12: new Square(1, 2,  0x12),
            0x22: new Square(2, 2,  0x22),
            0x32: new Square(3, 2,  0x32),
            0x42: new Square(4, 2,  0x42),
            0x52: new Square(5, 2,  0x52),
            0x62: new Square(6, 2,  0x62),
            0x72: new Square(7, 2,  0x72),
            
            0x03: new Square(0, 3,  0x03),
            0x13: new Square(1, 3,  0x13),
            0x23: new Square(2, 3,  0x23),
            0x33: new Square(3, 3,  0x33),
            0x43: new Square(4, 3,  0x43),
            0x53: new Square(5, 3,  0x53),
            0x63: new Square(6, 3,  0x63),
            0x73: new Square(7, 3,  0x73),
            
            0x04: new Square(0, 4,  0x04),
            0x14: new Square(1, 4,  0x14),
            0x24: new Square(2, 4,  0x24),
            0x34: new Square(3, 4,  0x34),
            0x44: new Square(4, 4,  0x44),
            0x54: new Square(5, 4,  0x54),
            0x64: new Square(6, 4,  0x64),
            0x74: new Square(7, 4,  0x74),
            
            0x05: new Square(0, 5,  0x05),
            0x15: new Square(1, 5,  0x15),
            0x25: new Square(2, 5,  0x25),
            0x35: new Square(3, 5,  0x35),
            0x45: new Square(4, 5,  0x45),
            0x55: new Square(5, 5,  0x55),
            0x65: new Square(6, 5,  0x65),
            0x75: new Square(7, 5,  0x75),
            
            0x06: new Square(0, 6,  0x06),
            0x16: new Square(1, 6,  0x16),
            0x26: new Square(2, 6,  0x26),
            0x36: new Square(3, 6,  0x36),
            0x46: new Square(4, 6,  0x46),
            0x56: new Square(5, 6,  0x56),
            0x66: new Square(6, 6,  0x66),
            0x76: new Square(7, 6,  0x76),
            
            0x07: new Square(0, 7,  0x07),
            0x17: new Square(1, 7,  0x17),
            0x27: new Square(2, 7,  0x27),
            0x37: new Square(3, 7,  0x37),
            0x47: new Square(4, 7,  0x47),
            0x57: new Square(5, 7,  0x57),
            0x67: new Square(6, 7,  0x67),
            0x77: new Square(7, 7,  0x77)
        },
        
        // Encode x and y coordinates into fancy(/whimsical) hex byte key
        makeGridKey: function(x, y)
        {
            return (x << 4) | y;
        },
        
        getSquare: function(x, y)
        {
            var key = this.makeGridKey(x, y);
            
            if (!(key in this.squares))
                return null;
            
            return this.squares[key];
        },
        
        checkAnyMatchesTo: function(currSquare)
        {
            var hMatches = 1 + this.numMatchesTo(currSquare, Direction.Left) + this.numMatchesTo(currSquare, Direction.Right);
            if (hMatches >= 3)
                return true;
           
            var vMatches = 1 + this.numMatchesTo(currSquare, Direction.Up) + this.numMatchesTo(currSquare, Direction.Down);
            if (vMatches >= 3)
                return true;
           
            return false;
        },
        
        // returns array of squares of length `number` starting from `fromSquare` and going in `direction` on the grid
        getNumSquaresFrom_InDir: function(number, fromSquare, direction)
        {
            if (number <= 0 || fromSquare == null) // passed 0 or over the edge of the grid
                return [];  // return empty array
            
            var nextSquare = fromSquare.neighborInDir(direction);
            //var arrOfSquares;
            number--;
    
            return [fromSquare].concat(Game.Grid.getNumSquaresFrom_InDir(number, nextSquare, direction));
            
            /*if (number)
            {
                arrOfSquares = this.getNumSquaresFrom_InDir(number, nextSquare, direction);
            }
            else
                arrOfSquares = [];
            
            arrOfSquares.push(fromSquare);
            
            return arrOfSquares;*/
        },
        // returns array of squares from `fromSquare` to end of grid going in `direction`
        getAllSquaresFrom_InDir: function(fromSquare, direction)
        {
            return Game.Grid.getNumSquaresFrom_InDir(8, fromSquare, direction);
        },
        
        forNumSquaresFrom_InDir: function(number, fromSquare, direction, funcDo)
        {
            if (number <= 0 || fromSquare == null) // passed 0 or over the edge of the grid
                return;
    
            funcDo(fromSquare);
            
            var nextSquare = fromSquare.neighborInDir(direction);
            number--;
    
            Game.Grid.forNumSquaresFrom_InDir(number, nextSquare, direction, funcDo);
        },
    
        forAllSquaresFrom_InDir: function(fromSquare, direction, funcDo)
        {
            Game.Grid.forNumSquaresFrom_InDir(8, fromSquare, direction, funcDo);
        },
        
        numMatchesTo: function(fromSquare, direction)
        {
            var nextSquare = fromSquare.neighborInDir(direction);
            
            
            if (nextSquare == null || fromSquare.quark != nextSquare.quark)
                return 0;
            
            return 1 + this.numMatchesTo(nextSquare, direction);
        },
    },
    
    // swapQuarks – called from view.js
    swapQuarks: function(squareA, squareB)
    {
        var quarkA = squareA.quark;
        var quarkB = squareB.quark;
        
        if (quarkA == quarkB) // switching identical quarks will never produce a match
        {
            Game.eventTarget.trigger(Game.EventType.BoardSwapFail, [squareA, squareB]);
            
            return;
        }
        
        // Temporarily swap quarks to check if a match is produced
        squareA.quark = quarkB;
        squareB.quark = quarkA;
        
        if (!(Game.Grid.checkAnyMatchesTo(squareA) || Game.Grid.checkAnyMatchesTo(squareB)))
        {   // Bust, switch back.
            squareA.quark = quarkA;
            squareB.quark = quarkB;
            
            Game.eventTarget.trigger(Game.EventType.BoardSwapFail, [squareA, squareB]);
            
            return;
        }
        
        //var squaresAandB = [squareA, squareB];
        squareA.dirty = true;
        squareB.dirty = true;
        //Game.dirtySquares.push(squareA, squareB);
        
        Game.eventTarget.trigger(Game.EventType.BoardSwapSuccess, [squareA, squareB]);
        
        //Game.processChangedSquares(squaresAandB);
        Game.processChangedSquares();
    },
    
    processChangedSquares: function()
    {
        var changedSquares = Game.dirtySquares.splice(); // shallow copy
        var matchSquares = Game.getMatchesForSquares(changedSquares);
        
        if (matchSquares.length > 0)
        {
            Game.removeMatches(matchSquares);
        }
        else // no matches found, board is stable, score chain is finished and can be added 
        {
            Game.movesMade++;
            
            //var eventData = [Game.turn];
            Game.player1Score += Game.player1ChainScore * Game.player1ChainMult;
            Game.player1ChainScore = 0;
            Game.player1ChainMult = 0;
            
            // eventData.push(Game.turn);
            // eventData.push(Game.player1Score);
            
            var eventData = [Game.player1Score];
            
          /*switch (Game.turn)
            {
                case 1:
                    //Game.turn = 2;
                    Game.player1Score += Game.player1ChainScore * Game.player1ChainMult;
                    Game.player1ChainScore = 0;
                    Game.player1ChainMult = 0;
                    
                    eventData.push(Game.turn);
                    eventData.push(Game.player1Score);
                    break;
                case 2:
                    //Game.turn = 1;
                    Game.player2Score += Game.player2ChainScore * Game.player2ChainMult;
                    Game.player2ChainScore = 0;
                    Game.player2ChainMult = 0;
                    
                    eventData.push(Game.turn);
                    eventData.push(Game.player2Score);
                    break;
            }*/
    
            // TODO: Replace timer loop with an event listener for some sort of "spawn animation done" event from the view
            if (Game.animating)
            {   // wait until finished
                var timer = window.setInterval(function()
                {
                    if (!Game.animating)
                    {
                        window.clearInterval(timer);
                        
                        Game.eventTarget.trigger(Game.EventType.BoardStable, eventData);
                        if (Game.movesMade >= Game.maxMoves)
                        {
                            Game.Over();
                        }
                    }
                }, 10);
            }
            else
            {
                Game.eventTarget.trigger(Game.EventType.BoardStable, eventData);
                if (Game.movesMade >= Game.maxMoves)
                {
                    Game.Over();
                }
            }
        }
    },
    
    // getMatchesForSquares
    getMatchesForSquares: function(squaresToMatch)
    {
        var matchSquares = [];
        
        squaresToMatch.forEach(function(currSquare)
        {
            currSquare.matchAlignment = Alignment.None; // reset matchAlignment
            
            var matches = false;
            
            var numMatchesToLeft = Game.Grid.numMatchesTo(currSquare, Direction.Left);
            var numMatchesToRight = Game.Grid.numMatchesTo(currSquare, Direction.Right);
            
            var numMatchesAbove = Game.Grid.numMatchesTo(currSquare, Direction.Up);
            var numMatchesBelow = Game.Grid.numMatchesTo(currSquare, Direction.Down);
            
            [Alignment.Horizontal, Alignment.Vertical].forEach(function(lineAlignment)
            {
                if ((lineAlignment === Alignment.Horizontal && 1 + numMatchesToLeft + numMatchesToRight >= 3) ||
                    (lineAlignment === Alignment.Vertical   && 1 + numMatchesAbove + numMatchesBelow >= 3))
                {
                    matches = true;
                    
                    var lineMatch = [currSquare]; // start with current square
                    
                    if (lineAlignment == Alignment.Horizontal)
                    {    
                        lineMatch = lineMatch.concat(Game.Grid.getNumSquaresFrom_InDir(numMatchesToLeft, currSquare.squareLeft, Direction.Left));
                        lineMatch = lineMatch.concat(Game.Grid.getNumSquaresFrom_InDir(numMatchesToRight, currSquare.squareRight, Direction.Right));
                    }
                    else // Alignment.Vertical
                    {
                        lineMatch = lineMatch.concat(Game.Grid.getNumSquaresFrom_InDir(numMatchesAbove, currSquare.squareAbove, Direction.Up));
                        lineMatch = lineMatch.concat(Game.Grid.getNumSquaresFrom_InDir(numMatchesBelow, currSquare.squareBelow, Direction.Down));
                    }
                    
                    var matchGravDir = currSquare.quark.gravDir;
                    var matchGravStrength = 0;
                    
                    // gravity direction parallel to match alignment
                    if ((lineAlignment === Alignment.Horizontal && (matchGravDir == Direction.Right || matchGravDir == Direction.Left)) ||
                        (lineAlignment === Alignment.Vertical   && (matchGravDir == Direction.Up    || matchGravDir == Direction.Down)))
                    {
                        matchGravStrength = lineMatch.length;
                    }
                    else // gravity direction perpendicular to match alignment
                    {
                        matchGravStrength = 1;
                    }
                    
                    // Probably won't use this...
                    // Game.gravCumulation[matchGravDir] += matchGravStrength; // increase priority for this grav direction
                    
                    // Create MatchGroup object that will be used later for gravity resolution
                    var matchGroup = new Game.MatchGroup();
                    var matchGroupIndex = -1;
                    
                    // store this match alignment in the square
                    lineMatch.forEach(function(lineSquare)
                    {
                        lineSquare.matchAlignment |= lineAlignment;
                        
                        // set a dirty flag on the square
                        lineSquare.dirty = true;
                        /*if (!lineSquare.dirty)
                        {
                            lineSquare.dirty = true;
                            Game.dirtySquares.push(lineSquare);
                        }*/
                        
                        lineSquare.gravDir = matchGravDir;
                        // if square already has a gravStrength, only change if new one is larger
                        lineSquare.gravStrength = Math.max(lineSquare.gravStrength, matchGravStrength);
                        
                        // store this square in the MatchGroup
                        //matchGroup.squares[lineSquare.gridKey] = lineSquare;
                        matchGroup.squares.push(lineSquare);
                                                
                        if (lineSquare.matchGroupIndex != -1) // if this square is already in a match group
                        {
                            if (matchGroupIndex != -1) // This shouldn't be possible.
                                console.log("DOUBLE ASSIGNING MATCH GROUP WHAAAT?");
                            
                            // store index of existing MatchGroup to merge with later
                            matchGroupIndex = lineSquare.matchGroupIndex;
                        }
                    });
                    //lineMatch.sort(Square.compareFunction);
                    
                    // either add matchGroup to Game.matchGroups, or merge with an existing group in Game.matchGroups
                    if (matchGroupIndex == -1) // if matchGroupIndex wasn't assigned in the forEach above, then matchGroup is new
                    {
                        matchGroup.assignIndex(Game.matchGroups.length);
                        Game.matchGroups.push(matchGroup);
                    }
                    else // merge with existing MatchGroup
                    {
                        matchGroup.assignIndex(matchGroupIndex);
                        
                        // merge objects (using jQuery)
                        //$.extend(Game.matchGroups[matchGroupIndex].squares, matchGroup.squares);
                        
                        // merge arrays
                        //Game.matchGroups[matchGroupIndex].squares = Game.matchGroups[matchGroupIndex].squares.union(matchGroup.squares); // using array extension in array.js
                        Game.matchGroups[matchGroupIndex].squares = Square.Array.union(Game.matchGroups[matchGroupIndex].squares, matchGroup.squares);
                    }
                    
                    // rowMatches.push(lineMatch);
                    matchSquares = matchSquares.concat(lineMatch);
                }
            });
            
            // when dirty square is confirmed to have no matches, remove dirty flag 
            if (!matches && currSquare.dirty)
            {
                currSquare.dirty = false;
                //Game.dirtySquares.remove(currSquare);
            }
        });
        
        //return matchData;
        //return hMatchSquares.concat(vMatchSquares);
        return matchSquares;
    },
    
    //removeMatches: function(matchData)
    removeMatches: function(matchSquares)
    {
        var matchPoints = matchSquares.length * 100;
        
        // set square quarks to null
        matchSquares.forEach(function(currSquare)
        {
            currSquare.quark = null;
            
            if (currSquare.state == Square.State.Quark) // state hasn't been updated yet
            {
                // get adjacent square in direction opposite to gravDir
                //var oppSquare = currSquare.neighborInDir(Direction.getOpposite(currSquare.gravDir));
                var oppSquare = currSquare.neighborInDir(currSquare.gravDir.opposite);
                if (oppSquare != null && oppSquare.gravDir === currSquare.gravDir.opposite)
                {
                    //Game.gravBombs[currSquare.gridKey] = currSquare;
                    //Game.gravBombs[oppSquare.gridKey] = oppSquare;
                    Game.gravBombs.push([currSquare, oppSquare]);
                    
                    currSquare.state = Square.State.GravityBomb;
                    oppSquare.state = Square.State.GravityBomb;
                    
                    // remove grav bombs from match groups
                    if (currSquare.matchGroupIndex != -1) // this check might be redundant
                    {
                        //delete Game.matchGroups[currSquare.matchGroupIndex].squares[currSquare.gridKey];
                        Game.matchGroups[currSquare.matchGroupIndex].squares.remove(currSquare);
                        currSquare.matchGroupIndex = -1;
                    }
                    if (oppSquare.matchGroupIndex != -1) // this check might be redundant
                    {
                        //delete Game.matchGroups[oppSquare.matchGroupIndex].squares[oppSquare.gridKey];
                        Game.matchGroups[oppSquare.matchGroupIndex].squares.remove(oppSquare);
                        oppSquare.matchGroupIndex = -1;
                    }
                }
                else
                {
                    currSquare.state = Square.State.Gravity;
                }
            }
        });
        // sort match groups by total gravity strength, descending
        Game.matchGroups.sort(Game.MatchGroup.compareFunction);
        // re-index match groups
        Game.matchGroups.forEach(function(matchGroup, i)
        {
            matchGroup.assignIndex(i);
        });
        
        // create deep copy of match squares for sending to view 
        var eventData = [Square.Array.clone(matchSquares)];
        
        // just send coordinates of gravBombs to view
        var gravBombCoords = Game.gravBombs.map(function(gravBomb){ return [gravBomb[0].coords, gravBomb[1].coords]; });
        eventData.push(gravBombCoords);
        
        Game.player1ChainScore += matchPoints;
        Game.player1ChainMult += 1;
        eventData.push(Game.player1ChainScore);
        eventData.push(Game.player1ChainMult);
        
        /*switch (Game.turn)
        {
            case 1:
                Game.player1ChainScore += matchPoints;
                Game.player1ChainMult += 1;
                eventData.push(Game.player1ChainScore);
                eventData.push(Game.player1ChainMult);
                break;
            case 2:
                Game.player2ChainScore += matchPoints;
                Game.player2ChainMult += 1;
                eventData.push(Game.player2ChainScore);
                eventData.push(Game.player2ChainMult);
                break;
        }*/
    
        // TODO: Replace timer loop with an event listener for some sort of "swap animation done" event from the view
        if (Game.animating)
        {   // wait until finished
            var timer = window.setInterval(function()
            {
                if (!Game.animating)
                {
                    window.clearInterval(timer);
                    
                    Game.eventTarget.trigger(Game.EventType.BoardRemoveMatches, eventData);
                    // Game.spawnNewQuarks(matchData);
                    // Game.spawnNewQuarks(matchSquares);
                    Game.processGravity();
                }
            }, 10);
        }
        else
        {
            Game.eventTarget.trigger(Game.EventType.BoardRemoveMatches, eventData);
            // Game.spawnNewQuarks(matchData);
            // Game.spawnNewQuarks(matchSquares);
            Game.processGravity();
        }
    },
    
    processGravity: function()
    {
        //if (Object.keys(Game.gravHolesAll).length == 0 && Object.keys(Game.gravBombs).length == 0)
        if (Game.matchGroups.length == Object.keys(Game.resolvedMatchGroups).length  // all matchGroups resolved
            && Game.gravBombs.length == 0)
        {
            Game.matchGroups = [];
            Game.resolvedMatchGroups = {};
            
            Game.spawnNewQuarks();
        }
        else
        {
            console.log('==processGravity==');
            console.log('num resolvedMatchGroups', Object.keys(Game.resolvedMatchGroups).length);
            console.log('num gravBombs', Game.gravBombs.length);
            console.log();
            
            //// Standard Gravity
            if (Game.matchGroups.length > 0)
            {
                // Initial filtering of matchGroups to weed out obvious conflicts and map dependencies
                var groupsGoodToGrav = Game.matchGroups.filter(function(matchGroup)
                {
                    return matchGroup.goodToGrav;
                });
                
                var gravSquares = [];
                for (var i = 0; i < groupsGoodToGrav.length; i++)
                {   var matchGroup = groupsGoodToGrav[i];
                    
                    if (matchGroup.resolved) // already resolved (as a dependency of a previous matchGroup)
                        continue;
                    
                    // initial values
                    var expandedGroup = [matchGroup],
                        allDependentSquares = matchGroup.squares.splice(); // shallow copy
                    // now we add some more
                    for (var index in matchGroup.expandedDependencies)
                    {   var dependency = matchGroup.dependencies[index];
                        
                        if (!dependency.resolved && dependency.index != matchGroup.index)
                        {
                            expandedGroup.push(dependency);
                            allDependentSquares = allDependentSquares.concat(dependency.squares);
                        }
                    }
                    
                    var cloneSquareHash = {};
                    // see if any two gravity-source squares try to set differing gravity on the same outside-square
                    var greatToGrav = allDependentSquares.every(function(square)
                    {
                        var pullSquare = square.neighborInDir(square.gravDir.opposite);
                        if (!pullSquare.inSameGroupAs(square)) // this square directly pulls on a square outside the match group
                        {
                            // clone squares so we can set test values without changing the real thing
                            var cloneSquares = Square.Array.clone(Game.Grid.getAllSquaresFrom_InDir(pullSquare, square.gravDir.opposite)); 
                            return cloneSquares.every(function(cloneSquare)
                            {
                                if (cloneSquare.gravDir == null || cloneSquare.gravDir == square.gravDir)
                                {
                                    cloneSquare.gravDir = square.gravDir;
                                    
                                    if (cloneSquare.gridKey in cloneSquareHash)
                                    {   // if previously-set gravity is different we have conflict
                                        return cloneSquareHash[cloneSquare.gridKey].gravDir == cloneSquare.gravDir;
                                    }
                                    
                                    cloneSquareHash[cloneSquare.gridKey] = cloneSquare;
                                    return true;
                                }
                                return false;
                            });
                        }
                        return true;
                    });
                    
                    if (!greatToGrav)
                        continue;
                    
                    var holesSeen = {}; // so we only apply extra gravity to fill a hole the first time we see it
                    // loop through again, this time setting real values
                    for (var x = 0; x < allDependentSquares.length; x++)
                    {   var square = allDependentSquares[x];
                        
                        var behind = square.gravDir,
                            ahead  = square.gravDir.opposite;
                        
                        // Check if the square before this one in this row/column had the same gravity direction in cloneSquareHash
                        // (and therefore this square isn't the "start" of this gravity)
                        if (cloneSquareHash[square.neighborInDir(behind).gridKey].gravDir == square.gravDir)
                            continue;  // skip it, want the actual start
                        
                        var gravLine = Game.Grid.getAllSquaresFrom_InDir(square, ahead);
                        gravLine.forEach(function(lineSquare){ lineSquare.gravApplied += square.gravStrength; });
                        
                        // find additional holes in the line and apply gravity accordingly
                        for (i = square.gravStrength; i < gravLine.length; i++)
                        {   var holeMaybe = gravLine[i];
                            
                            if (holeMaybe.quark == null && holeMaybe.gravStrength == null) // unmeasured hole
                            {
                                for (var holePos = i; holePos < gravLine.length; holePos++)
                                {
                                    if (gravLine[holePos].quark != null || gravLine[holePos].gravStrength != null)
                                        break;
                                }
                                var holeSize = holePos - i;
                                
                                Game.Grid.forNumSquaresFrom_InDir(holeSize, holeMaybe, ahead, function(holeSquare)
                                {
                                    holeSquare.gravStrength = holeSize;
                                    holeSquare.state = Square.State.Gravity;
                                });
                            }
                            
                            if (holeMaybe.quark == null && holeMaybe.gravStrength != null) // measured hole
                            {
                                var howFarBack = holeMaybe.neighborInDir(behind).gravApplied;
    
                                Game.Grid.forAllSquaresFrom_InDir(holeMaybe.nth_NeighborInDir(howFarBack, behind), ahead, function(affectedSquare)
                                {
                                    affectedSquare.gravApplied += holeMaybe.gravStrength;
                                });
                                
                                i += holeMaybe.gravStrength - 1;
                            }
                        }
                        
                        /*var gravSquaresTemp = [square];
                        
                        var pullSquare = square.neighborInDir(square.gravDir.opposite);
                        if (!pullSquare.inSameGroupAs(square)) // this square directly pulls on a square outside the match group
                        {
                            var extraHoleGravity = 0;
                            var setSquares = Game.Grid.getAllSquaresFrom_InDir(pullSquare, square.gravDir.opposite);
                            setSquares.forEach(function(setSquare)
                            {
                                setSquare.gravDir = square.gravDir;
                                
                                if (!setSquare.quark && !(setSquare.gridKey in holesSeen)) // hole we haven't seen before
                                {
                                    extraHoleGravity++;
                                    holesSeen[setSquare.gridKey] = setSquare.gravDir;
                                }
                                
                                setSquare.gravApplied += square.gravStrength + extraHoleGravity;
                                
                                setSquare.dirty = true;
                            });
                            
                            gravSquaresTemp = gravSquaresTemp.concat(setSquares);
                        }*/
                        
                        //gravSquares = Square.Array.union(gravSquares, gravSquaresTemp);
                        gravSquares = gravSquares.concat(gravLine);
                    }
                    
                    //Game.matchGroups.remove(matchGroup);
                    
                    // add groups to resolved list
                    expandedGroup.forEach(function(resolvedGroup)
                    {
                        Game.resolvedMatchGroups[resolvedGroup.index] = resolvedGroup;
                    });
                }
                
                if (gravSquares.length > 0)
                {
                    // deep copy gravSquares
                    var oldSquares = Square.Array.clone(gravSquares);
                    
                    // start movin' quarks
                    gravSquares.forEach(function(currSquare, i)
                    {
                        var swapSquare = oldSquares[i].nth_NeighborInDir(currSquare.gravApplied, currSquare.gravDir.opposite);
                        
                        if (!swapSquare || !swapSquare.quark) // passed edge of grid or swapSquare has no quark
                        {
                            currSquare.quark = null;
                            currSquare.state = Square.State.Empty;
                        }
                        else
                        {
                            currSquare.quark = swapSquare.quark;
                            currSquare.state = Square.State.Quark;
                        }
                        
                        currSquare.gravDir = null;
                        currSquare.gravStrength = null;
                        currSquare.gravApplied = 0;
                    });
                    
                    // copy quarks over from gravSquares to oldSquares
                    for (i = 0; i < gravSquares.length; i++)
                    {
                        oldSquares[i].quark = gravSquares[i].quark;
                    }
                    
                    var eventData = [oldSquares];
                    
                    if (Game.animating)
                    {   // wait until finished
                        // TODO: Replace timer loop with an event listener for some sort of "gravity animation done" event from the view
                        var timer = window.setInterval(function()
                        {
                            if (!Game.animating)
                            {
                                window.clearInterval(timer);
                
                                Game.eventTarget.trigger(Game.EventType.BoardGravity, eventData);
                                Game.processGravity();
                            }
                        }, 10);
                    }
                    else
                    {
                        Game.eventTarget.trigger(Game.EventType.BoardGravity, eventData);
                        Game.processGravity();
                    }
                }
                else
                    console.log("Couldn't gravitize any match groups! D:");
            }
            //// Gravity Bombs
            else
            {
                var bombedSquares = [];
                
                Game.gravBombs.forEach(function(gravBomb) // each gravBomb is an array of two squares
                {
                    var align = Math.abs(gravBomb[0].gridKey - gravBomb[1].gridKey); // will equal Alignment.Vertical or Alignment.Horizontal
                    
                    var x, y, direction;
                    // get coordinates of first square in line to be destroyed
                    switch (align)
                    {
                        case Alignment.Horizontal:
                            x = 0;
                            y = gravBomb[0].y;
                            direction = Direction.Right;
                            break;
                        case Alignment.Vertical:
                            x = gravBomb[0].x;
                            y = 0;
                            direction = Direction.Down;
                            break;
                        default:
                            throw "gravBomb alignment not horizontal or vertical, instead = " + align;
                    }
                    
                    var lineSquares = Game.Grid.getAllSquaresFrom_InDir(Game.Grid.getSquare(x, y), direction);
                    lineSquares.forEach(function(lineSquare)
                    {
                        lineSquare.quark = null;
                        lineSquare.state = Square.State.Empty;
                        
                        lineSquare.dirty = true;
                    });
                    
                    Square.Array.union(bombedSquares, lineSquares);
                });
                
                eventData = [Square.Array.clone(bombedSquares)];
    
                // just send coordinates of gravBombs to view
                var gravBombCoords = Game.gravBombs.map(function(gravBomb){ return [gravBomb[0].coords, gravBomb[1].coords]; });
                eventData.push(gravBombCoords);
                
                // TODO: Quarks destroyed by gravity bomb add to score
                
                Game.gravBombs = [];
    
                if (Game.animating)
                {   // wait until finished
                    // TODO: Replace timer loop with an event listener for some sort of "gravity animation done" event from the view
                    timer = window.setInterval(function()
                    {
                        if (!Game.animating)
                        {
                            window.clearInterval(timer);
                
                            Game.eventTarget.trigger(Game.EventType.BoardGravityBomb, eventData);
                            Game.processGravity();
                        }
                    }, 10);
                }
                else
                {
                    Game.eventTarget.trigger(Game.EventType.BoardGravityBomb, eventData);
                    Game.processGravity();
                }
            }
            
            //// TEMPORARY
            // for now new quarks will just appear where the old ones were
            //Game.gravBombs = [];
            //Game.matchGroups = [];
            //Game.resolvedMatchGroups = {};
            //
            //Game.processGravity();
        }
    },
    
    // spawnNewQuarks: function(matchData)
    spawnNewQuarks: function()
    {
        var fillSquares = [];
        for (var gridKey in Game.Grid.squares)
        {   var square = Game.Grid.squares[gridKey];
            
            if (square.state == Square.State.Empty)
                fillSquares.push(square);
        }
        
        fillSquares.forEach(function(currSquare)
        {
            currSquare.spawnQuark();
            //currSquare.quark = Quark.getRandomQuark();
            //currSquare.state = Square.State.Quark;
        });
        
        // TODO: Replace timer loop with an event listener for some sort of "gravity animation done" event from the view
        if (Game.animating)
        {   // wait until finished
            var timer = window.setInterval(function()
            {
                if (!Game.animating)
                {
                    window.clearInterval(timer);
                    
                    Game.eventTarget.trigger(Game.EventType.BoardNewQuarks, [Square.Array.clone(fillSquares)]);
                    //Game.processChangedSquares(fillSquares);
                    Game.processChangedSquares();
                }
            }, 10);
        }
        else
        {
            Game.eventTarget.trigger(Game.EventType.BoardNewQuarks, [Square.Array.clone(fillSquares)]);
            //Game.processChangedSquares(fillSquares);
            Game.processChangedSquares();
        }
    },
    
    // end game
    Over: function()
    {
        // if (Game.player1Score == Game.player2Score)
        // {
        //     Game.eventTarget.trigger(Game.EventType.GameOver, [0]);
        // }
        // else if (Game.player1Score > Game.player2Score)
        // {
        //     Game.eventTarget.trigger(Game.EventType.GameOver, [1]);
        // }
        // else
        // {
        //     Game.eventTarget.trigger(Game.EventType.GameOver, [2]);
        // }
        
        Game.eventTarget.trigger(Game.EventType.GameOver, [1]);
    }
};
Game.MatchGroup = function()
{
    this.index = -1;
    this.squares = []; // {};
    
    // tentative "can be resolved" flag, not taking into account dependencies.
    this._goodToGrav = null;
    
    // Length of Game.matchGroups when _checkConflicts was last called
    // If different from current Game.matchGroups.length, _checkConflicts will be called again when goodToGrav property is accessed 
    this._lastResolvedGroupsLength = -1;
    
    // Hash of other match groups that need to be goodToGrav in order for this one to be
    this.dependencies = {};
};
Game.MatchGroup.prototype.assignIndex = function(index)
{
    this.index = index;
    
    this.squares.forEach(function(square)
    {
        square.matchGroupIndex = index;
    });
};
Game.MatchGroup.prototype.totalGravStrength = function()
{
    var total = 0;
    
    this.squares.forEach(function(square)
    {            
        total += square.gravStrength;
    });
    
    return total;
};
Game.MatchGroup.prototype.inArray = function(matchGroupArray)
{
    return matchGroupArray.some(function(arrayGroup)
    {
        return this.index == arrayGroup.index;
    }, this);
};
Object.defineProperty(Game.MatchGroup.prototype, 'expandedDependencies',
{
    get: function()
    {
        var expanded = this.dependencies;
        
        for (var index in this.dependencies)
        {   var dependency = this.dependencies[index];
    
            $.extend(expanded, dependency.expandedDependencies);
        }
        
        return expanded;
    }
});
Object.defineProperty(Game.MatchGroup.prototype, 'resolved',
{
    get: function()
    {
        return this.index in Game.resolvedMatchGroups;
    }
});
// called by goodToGrav property when needed
Game.MatchGroup.prototype._checkConflicts = function()
{
    this.dependencies = {}; // empty previous dependencies
    this._lastResolvedGroupsLength = Object.keys(Game.resolvedMatchGroups).length;
    
    var thisGroup = this; // store this context for use inside iterators
    
    this._goodToGrav = this.squares.every(function(square)
    {
        var pullSquare = square.neighborInDir(square.gravDir.opposite);
        if (!pullSquare.inSameGroupAs(square)) // this square directly pulls on a square outside the match group
        {
            // get all the squares from pullSquare to the end of the grid
            var checkSquares = Game.Grid.getAllSquaresFrom_InDir(pullSquare, square.gravDir.opposite);
            
            return checkSquares.every(function(checkSquare)
            {
                if (checkSquare.gravDir == null) // checked square has no gravity
                    return true; // no gravity, no conflict
                else if (checkSquare.gravDir == square.gravDir) // we have the same gravity
                {
                    if (checkSquare.inMatchGroup && !checkSquare.inSameGroupAs(square)) // checked square is in a different MatchGroup
                    {   // our match group's resolve-ability now depends on this other one's
                        thisGroup.dependencies[checkSquare.matchGroupIndex] = Game.matchGroups[checkSquare.matchGroupIndex];
                    }
                    
                    return true;
                }
                else // conflict
                    return false;
            });
        }
        return true;
    });
};
Object.defineProperty(Game.MatchGroup.prototype, 'goodToGrav',
{
    get: function()
    {
        if (this._lastResolvedGroupsLength != Game.matchGroups.length) // Mismatch, call _checkConflicts() to update
            this._checkConflicts(); // check for conflicts and dependencies
        
        if (this._goodToGrav)
        {
            var dependenciesGoodToGrav = true;
            for (var index in this.dependencies)
            {   var dependency = this.dependencies[index];
                
                if (!dependency.goodToGrav)
                {
                    dependenciesGoodToGrav = false;
                    break;
                }
            }
            
            return dependenciesGoodToGrav;
        }
        
        return false;
    }
});
Game.MatchGroup.compareFunction = function(groupA, groupB)
{
    //return groupA.totalGravStrength - groupB.totalGravStrength;
    return groupB.totalGravStrength - groupA.totalGravStrength; // sort descending
};

// EffectDatum object constructor
Game.EffectDatum = function(startSquare, alignment, length)
{
    this.startSquare = startSquare;
    this.alignment = alignment;
    this.length = length;
};

/**
 * Creates a new instance of class Square.
 * @class Represents a square on the grid.
 * @param x X coordinate of the square.
 * @param y Y coordinate of the square.
 * @param gridKey X and Y coordinates encoded in hex, used as the key into <code>Game.Grid.squares</code>.
 */
function Square(x, y, gridKey)
{
    // I *think* using defineProperty here makes x, y, and gridKey read-only.
    Object.defineProperty(this, 'x',       { value: x,       enumerable: true });
    Object.defineProperty(this, 'y',       { value: y,       enumerable: true });
    Object.defineProperty(this, 'gridKey', { value: gridKey, enumerable: true });
    
    this.quark = null;
    
    this.gravDir = null;
    this.gravStrength = null;
    this.gravApplied = 0;
    
    this.matchAlignment = Alignment.None;
    this.matchGroupIndex = -1;
    this.state = 0; // Square.State.Empty
    
    this._dirty = false;
}
// enum definition
Square.State =
{
    Empty: 0,
    Quark: 1,
    Match: 2,
    Gravity: 3,
    GravityBomb: 4
};
/**
 * Flag for squares that have changed in some way and have not yet been checked for matches. Setting
 * to <code>true</code> automatically adds this square to <code>Game.dirtySquares</code>.
 * @type {boolean}
 * @name Square#dirty
 */
Object.defineProperty(Square.prototype, 'dirty',
{
    get: function()
    {
        return this._dirty;
    },
    set: function(newValue)
    {
        // current and new value both true
        if (this._dirty && newValue)
            return; // nothing to do
        
        // current value true and new value false
        if (this._dirty)
        {
            this._dirty = false;
            // remove from dirty squares list
            Game.dirtySquares.remove(this); // using Array extension in array.js
        }
        // current value false and new value true
        else if (newValue)
        {
            this._dirty = true;
            // add to dirty squares list
            Game.dirtySquares.push(this);
        }
    },
    enumerable: true
});
//// add some 'get adjacent square' properties to Square objects
Object.defineProperty(Square.prototype, 'squareAbove',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x, this.y-1); // evaluates to null when looking beyond edge of Grid
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareBelow',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x, this.y+1); // evaluates to null when looking beyond edge of Grid
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareLeft',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x-1, this.y); // evaluates to null when looking beyond edge of Grid
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'squareRight',
{
    get: function()
    {
        return Game.Grid.getSquare(this.x+1, this.y); // evaluates to null when looking beyond edge of Grid
    },
    enumerable: true
});
Square.prototype.neighborInDir = function(direction)
{
    switch (direction)
    {
     case Direction.Up:
        return this.squareAbove;
        break;
     case Direction.Down:
        return this.squareBelow;
        break;
     case Direction.Left:
        return this.squareLeft;
        break;
     case Direction.Right:
        return this.squareRight;
        break;
    }
};
Square.prototype.nth_NeighborInDir = function(n, direction)
{
    if (n == 0)
        return this;
    
    var nextSquare = this.neighborInDir(direction);
    if (!nextSquare)
        return null;
    
    return nextSquare.nth_NeighborInDir(n-1, direction);
};
Square.prototype.spawnQuark = function()
{
    this.quark = Quark.getRandomQuark();
    this.state = Square.State.Quark;
    
    this.gravDir = null;
    this.gravStrength = null;
    this.gravApplied = 0;
    
    this.matchAlignment = Alignment.None;
    this.matchGroupIndex = -1;
    
    this.dirty = true;
};
Object.defineProperty(Square.prototype, 'inMatchGroup',
{
    get: function()
    {
        return this.matchGroupIndex != -1;
    },
    enumerable: true
});
Object.defineProperty(Square.prototype, 'coords',
{
    get: function()
    {
        return {x: this.x, y: this.y};
    },
    enumerable: true
});
// Returns true if this square and otherSquare have the same non-negative matchGroupIndex
Square.prototype.inSameGroupAs = function(otherSquare)
{
    return (this.inMatchGroup && this.matchGroupIndex == otherSquare.matchGroupIndex);
};
// Returns whether this square and otherSquare have the same gridKey
Square.prototype.equals = function(otherSquare)
{
    return this.gridKey == otherSquare.gridKey;
};
// Returns an object copy of this Square.
Square.prototype.clone = function()
{
    return(
    {
        x               : this.x,
        y               : this.y,
        gridKey         : this.gridKey,
        
        quark           : this.quark,
        
        gravDir         : this.gravDir,
        gravStrength    : this.gravStrength,
        gravApplied     : this.gravApplied,
        
        matchAlignment  : this.matchAlignment,
        matchGroupIndex : this.matchGroupIndex,
        
        state           : this.state
    });
};
/** 
 * @namespace
 */
Square.Array =
{
    /**
     * Returns a deep copy of the passed array of Square objects.
     * @param {Array.<Square>} squaresArray Array of Squares to deep copy.
     * @returns {Array.<Square>}
     */
    clone: function(squaresArray)
    {
        return squaresArray.map(function(square){ return square.clone(); });
    },
    /**
     * Joins the two passed arrays of Square objects into one array with no duplicates.
     * @param {Array.<Square>} squaresArray1 First of two arrays to union.
     * @param {Array.<Square>} squaresArray2 Second of two arrays to union.
     * @returns {Array.<Square>}
     */
    union: function(squaresArray1, squaresArray2)
    {
        var hash = {};
        
        // add both arrays into a hash by gridKey to eliminate duplicates
        for (var i = 0; i < squaresArray1.length; i++)
            hash[squaresArray1[i].gridKey] = squaresArray1[i];
        for (i = 0; i < squaresArray2.length; i++)
            hash[squaresArray2[i].gridKey] = squaresArray2[i];
        
        // convert back to an array
        var union = [];
        for (var k in hash)
        {
            union.push(hash[k]);
        }
        
        return union;
    },
    containsSquare: function(squaresArray, square)
    {
        return squaresArray.some(function(arraySquare)
        {
            return arraySquare.equals(square);
        });
    }
};
// Comparison function for sorting arrays of squares. (Probably won't be used)
Square.compareFunction = function(squareA, squareB)
{
    return squareA.gridKey - squareB.gridKey;
};


//// Quark types
var Quark =
{
    RedLeft:
    {
        gravDir: Direction.Left,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-left'
    },
    BlueLeft:
    {
        gravDir: Direction.Left,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-left'
    },
    RedUp:
    {
        gravDir: Direction.Up,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-up'
    },
    BlueUp:
    {
        gravDir: Direction.Up,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-up'
    },
    RedRight:
    {
        gravDir: Direction.Right,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-right'
    },
    BlueRight:
    {
        gravDir: Direction.Right,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-right'
    },
    RedDown:
    {
        gravDir: Direction.Down,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-red arrow-down'
    },
    BlueDown:
    {
        gravDir: Direction.Down,
        // CSS classes to properly represent this quark in the DOM
        css: 'ring-blue arrow-down'
    },
    
    NumQuarkTypes: 8,
    
    getRandomQuark: function()
    {
        var quarkTypes = Object.keys(this);
        
        var randomIndex = Math.floor(Math.random() * this.NumQuarkTypes);
        return Quark[quarkTypes[randomIndex]];
    }
};


//// command-line only stuff for testing purposes
//if (typeof process != 'undefined')
//{    
//    console.log(Game.Grid.getSquare(5,3).neighborInDir(Direction.Up));
//}
